
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Marker-Controlled Watershed Segmentation</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="ipexwatershed.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexwatershed">Open ipexwatershed.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexwatershed">Run in the Command Window</a></div></div><div class="content"><h1>Marker-Controlled Watershed Segmentation</h1><!--introduction--><p>Separating touching objects in an image is one of the more difficult image processing operations.  The watershed transform is often applied to this problem.  The watershed transform finds "catchment basins" and "watershed ridge lines" in an image by treating it as a surface where light pixels are high and dark pixels are low.</p><p>Segmentation using the watershed transform works better if you can identify, or "mark," foreground objects and background locations. Marker-controlled watershed segmentation follows this basic procedure:</p><p>1. Compute a segmentation function.  This is an image whose dark regions are the objects you are trying to segment.</p><p>2. Compute foreground markers.  These are connected blobs of pixels within each of the objects.</p><p>3. Compute background markers.  These are pixels that are not part of any object.</p><p>4. Modify the segmentation function so that it only has minima at the foreground and background marker locations.</p><p>5. Compute the watershed transform of the modified segmentation function.</p><p>This example highlights many different Image Processing Toolbox&#8482; functions, including <tt>fspecial</tt>, <tt>imfilter</tt>, <tt>watershed</tt>, <tt>label2rgb</tt>, <tt>imopen</tt>, <tt>imclose</tt>, <tt>imreconstruct</tt>, <tt>imcomplement</tt>, <tt>imregionalmax</tt>, <tt>bwareaopen</tt>, <tt>graythresh</tt>, and <tt>imimposemin</tt>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Read in the Color Image and Convert it to Grayscale</a></li><li><a href="#2">Step 2: Use the Gradient Magnitude as the Segmentation Function</a></li><li><a href="#5">Step 3: Mark the Foreground Objects</a></li><li><a href="#14">Step 4: Compute Background Markers</a></li><li><a href="#16">Step 5: Compute the Watershed Transform of the Segmentation Function.</a></li><li><a href="#18">Step 6: Visualize the Result</a></li></ul></div><h2>Step 1: Read in the Color Image and Convert it to Grayscale<a name="1"></a></h2><pre class="codeinput">rgb = imread(<span class="string">'pears.png'</span>);
I = rgb2gray(rgb);
imshow(I)

text(732,501,<span class="string">'Image courtesy of Corel(R)'</span>,<span class="keyword">...</span>
     <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_01.png" alt=""> <h2>Step 2: Use the Gradient Magnitude as the Segmentation Function<a name="2"></a></h2><p>Use the Sobel edge masks, <tt>imfilter</tt>, and some simple arithmetic to compute the gradient magnitude.  The gradient is high at the borders of the objects and low (mostly) inside the objects.</p><pre class="codeinput">hy = fspecial(<span class="string">'sobel'</span>);
hx = hy';
Iy = imfilter(double(I), hy, <span class="string">'replicate'</span>);
Ix = imfilter(double(I), hx, <span class="string">'replicate'</span>);
gradmag = sqrt(Ix.^2 + Iy.^2);
figure, imshow(gradmag,[]), title(<span class="string">'Gradient magnitude (gradmag)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_02.png" alt=""> <p>Can you segment the image by using the watershed transform directly on the gradient magnitude?</p><pre class="codeinput">L = watershed(gradmag);
Lrgb = label2rgb(L);
figure, imshow(Lrgb), title(<span class="string">'Watershed transform of gradient magnitude (Lrgb)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_03.png" alt=""> <p>No.  Without additional preprocessing such as the marker computations below, using the watershed transform directly often results in "oversegmentation."</p><h2>Step 3: Mark the Foreground Objects<a name="5"></a></h2><p>A variety of procedures could be applied here to find the foreground markers, which must be connected blobs of pixels inside each of the foreground objects.  In this example you'll use morphological techniques called "opening-by-reconstruction" and "closing-by-reconstruction" to "clean" up the image.  These operations will create flat maxima inside each object that can be located using <tt>imregionalmax</tt>.</p><p>Opening is an erosion followed by a dilation, while opening-by-reconstruction is an erosion followed by a morphological reconstruction.  Let's compare the two.  First, compute the opening using <tt>imopen</tt>.</p><pre class="codeinput">se = strel(<span class="string">'disk'</span>, 20);
Io = imopen(I, se);
figure, imshow(Io), title(<span class="string">'Opening (Io)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_04.png" alt=""> <p>Next compute the opening-by-reconstruction using <tt>imerode</tt> and <tt>imreconstruct</tt>.</p><pre class="codeinput">Ie = imerode(I, se);
Iobr = imreconstruct(Ie, I);
figure, imshow(Iobr), title(<span class="string">'Opening-by-reconstruction (Iobr)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_05.png" alt=""> <p>Following the opening with a closing can remove the dark spots and stem marks.  Compare a regular morphological closing with a closing-by-reconstruction.  First try <tt>imclose</tt>:</p><pre class="codeinput">Ioc = imclose(Io, se);
figure, imshow(Ioc), title(<span class="string">'Opening-closing (Ioc)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_06.png" alt=""> <p>Now use <tt>imdilate</tt> followed by <tt>imreconstruct</tt>.  Notice you must complement the image inputs and output of <tt>imreconstruct</tt>.</p><pre class="codeinput">Iobrd = imdilate(Iobr, se);
Iobrcbr = imreconstruct(imcomplement(Iobrd), imcomplement(Iobr));
Iobrcbr = imcomplement(Iobrcbr);
figure, imshow(Iobrcbr), title(<span class="string">'Opening-closing by reconstruction (Iobrcbr)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_07.png" alt=""> <p>As you can see by comparing <tt>Iobrcbr</tt> with <tt>Ioc</tt>, reconstruction-based opening and closing are more effective than standard opening and closing at removing small blemishes without affecting the overall shapes of the objects.  Calculate the regional maxima of <tt>Iobrcbr</tt> to obtain good foreground markers.</p><pre class="codeinput">fgm = imregionalmax(Iobrcbr);
figure, imshow(fgm), title(<span class="string">'Regional maxima of opening-closing by reconstruction (fgm)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_08.png" alt=""> <p>To help interpret the result, superimpose the foreground marker image on the original image.</p><pre class="codeinput">I2 = I;
I2(fgm) = 255;
figure, imshow(I2), title(<span class="string">'Regional maxima superimposed on original image (I2)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_09.png" alt=""> <p>Notice that some of the mostly-occluded and shadowed objects are not marked, which means that these objects will not be segmented properly in the end result.  Also, the foreground markers in some objects go right up to the objects' edge.  That means you should clean the edges of the marker blobs and then shrink them a bit.  You can do this by a closing followed by an erosion.</p><pre class="codeinput">se2 = strel(ones(5,5));
fgm2 = imclose(fgm, se2);
fgm3 = imerode(fgm2, se2);
</pre><p>This procedure tends to leave some stray isolated pixels that must be removed.  You can do this using <tt>bwareaopen</tt>, which removes all blobs that have fewer than a certain number of pixels.</p><pre class="codeinput">fgm4 = bwareaopen(fgm3, 20);
I3 = I;
I3(fgm4) = 255;
figure, imshow(I3)
title(<span class="string">'Modified regional maxima superimposed on original image (fgm4)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_10.png" alt=""> <h2>Step 4: Compute Background Markers<a name="14"></a></h2><p>Now you need to mark the background.  In the cleaned-up image, <tt>Iobrcbr</tt>, the dark pixels belong to the background, so you could start with a thresholding operation.</p><pre class="codeinput">bw = im2bw(Iobrcbr, graythresh(Iobrcbr));
figure, imshow(bw), title(<span class="string">'Thresholded opening-closing by reconstruction (bw)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_11.png" alt=""> <p>The background pixels are in black, but ideally we don't want the background markers to be too close to the edges of the objects we are trying to segment.  We'll "thin" the background by computing the "skeleton by influence zones", or SKIZ, of the foreground of <tt>bw</tt>. This can be done by computing the watershed transform of the distance transform of <tt>bw</tt>, and then looking for the watershed ridge lines (<tt>DL == 0</tt>) of the result.</p><pre class="codeinput">D = bwdist(bw);
DL = watershed(D);
bgm = DL == 0;
figure, imshow(bgm), title(<span class="string">'Watershed ridge lines (bgm)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_12.png" alt=""> <h2>Step 5: Compute the Watershed Transform of the Segmentation Function.<a name="16"></a></h2><p>The function <tt>imimposemin</tt> can be used to modify an image so that it has regional minima only in certain desired locations.  Here you can use <tt>imimposemin</tt> to modify the gradient magnitude image so that its only regional minima occur at foreground and background marker pixels.</p><pre class="codeinput">gradmag2 = imimposemin(gradmag, bgm | fgm4);
</pre><p>Finally we are ready to compute the watershed-based segmentation.</p><pre class="codeinput">L = watershed(gradmag2);
</pre><h2>Step 6: Visualize the Result<a name="18"></a></h2><p>One visualization technique is to superimpose the foreground markers, background markers, and segmented object boundaries on the original image.  You can use dilation as needed to make certain aspects, such as the object boundaries, more visible.  Object boundaries are located where <tt>L == 0</tt>.</p><pre class="codeinput">I4 = I;
I4(imdilate(L == 0, ones(3, 3)) | bgm | fgm4) = 255;
figure, imshow(I4)
title(<span class="string">'Markers and object boundaries superimposed on original image (I4)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_13.png" alt=""> <p>This visualization illustrates how the locations of the foreground and background markers affect the result.  In a couple of locations, partially occluded darker objects were merged with their brighter neighbor objects because the occluded objects did not have foreground markers.</p><p>Another useful visualization technique is to display the label matrix as a color image.  Label matrices, such as those produced by <tt>watershed</tt> and <tt>bwlabel</tt>, can be converted to truecolor images for visualization purposes by using <tt>label2rgb</tt>.</p><pre class="codeinput">Lrgb = label2rgb(L, <span class="string">'jet'</span>, <span class="string">'w'</span>, <span class="string">'shuffle'</span>);
figure, imshow(Lrgb)
title(<span class="string">'Colored watershed label matrix (Lrgb)'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_14.png" alt=""> <p>You can use transparency to superimpose this pseudo-color label matrix on top of the original intensity image.</p><pre class="codeinput">figure, imshow(I), hold <span class="string">on</span>
himage = imshow(Lrgb);
set(himage, <span class="string">'AlphaData'</span>, 0.3);
title(<span class="string">'Lrgb superimposed transparently on original image'</span>)
</pre><img vspace="5" hspace="5" src="ipexwatershed_15.png" alt=""> <p class="footer">Copyright 1993-2008 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Marker-Controlled Watershed Segmentation
% Separating touching objects in an image is one of the more difficult
% image processing operations.  The watershed transform is often applied to
% this problem.  The watershed transform finds "catchment basins" and
% "watershed ridge lines" in an image by treating it as a surface where
% light pixels are high and dark pixels are low.
%
% Segmentation using the watershed transform works better if you can
% identify, or "mark," foreground objects and background locations.
% Marker-controlled watershed segmentation follows this basic procedure:
%
% 1. Compute a segmentation function.  This is an image whose dark
% regions are the objects you are trying to segment.
%
% 2. Compute foreground markers.  These are connected blobs of pixels
% within each of the objects.
%
% 3. Compute background markers.  These are pixels that are not part of
% any object.
%
% 4. Modify the segmentation function so that it only has minima at the
% foreground and background marker locations.
% 
% 5. Compute the watershed transform of the modified segmentation function.
%
% This example highlights many different Image Processing Toolbox(TM)
% functions, including |fspecial|, |imfilter|, |watershed|, |label2rgb|,
% |imopen|, |imclose|, |imreconstruct|, |imcomplement|, |imregionalmax|,
% |bwareaopen|, |graythresh|, and |imimposemin|.

% Copyright 1993-2008 The MathWorks, Inc.
% $Revision: 1.1.6.6 $  $Date: 2008/07/09 18:11:09 $

%% Step 1: Read in the Color Image and Convert it to Grayscale

rgb = imread('pears.png');
I = rgb2gray(rgb);
imshow(I)

text(732,501,'Image courtesy of Corel(R)',...
     'FontSize',7,'HorizontalAlignment','right')

%% Step 2: Use the Gradient Magnitude as the Segmentation Function
% Use the Sobel edge masks, |imfilter|, and some simple arithmetic to
% compute the gradient magnitude.  The gradient is high at the borders of
% the objects and low (mostly) inside the objects.

hy = fspecial('sobel');
hx = hy';
Iy = imfilter(double(I), hy, 'replicate');
Ix = imfilter(double(I), hx, 'replicate');
gradmag = sqrt(Ix.^2 + Iy.^2);
figure, imshow(gradmag,[]), title('Gradient magnitude (gradmag)')

%% 
% Can you segment the image by using the watershed transform directly on
% the gradient magnitude?

L = watershed(gradmag);
Lrgb = label2rgb(L);
figure, imshow(Lrgb), title('Watershed transform of gradient magnitude (Lrgb)')

%%
% No.  Without additional preprocessing such as the marker computations below,
% using the watershed transform directly often results in
% "oversegmentation."

%% Step 3: Mark the Foreground Objects
% A variety of procedures could be applied here to find the foreground
% markers, which must be connected blobs of pixels inside each of the
% foreground objects.  In this example you'll use morphological
% techniques called "opening-by-reconstruction" and
% "closing-by-reconstruction" to "clean" up the image.  These
% operations will create flat maxima inside each object that can be
% located using |imregionalmax|.

%%
% Opening is an erosion followed by a dilation, while
% opening-by-reconstruction is an erosion followed by a morphological
% reconstruction.  Let's compare the two.  First, compute the opening using
% |imopen|.

se = strel('disk', 20);
Io = imopen(I, se);
figure, imshow(Io), title('Opening (Io)')

%%
% Next compute the opening-by-reconstruction using |imerode| and
% |imreconstruct|.

Ie = imerode(I, se);
Iobr = imreconstruct(Ie, I);
figure, imshow(Iobr), title('Opening-by-reconstruction (Iobr)')

%%
% Following the opening with a closing can remove the dark spots
% and stem marks.  Compare a regular morphological closing with a
% closing-by-reconstruction.  First try |imclose|:

Ioc = imclose(Io, se);
figure, imshow(Ioc), title('Opening-closing (Ioc)')

%%
% Now use |imdilate| followed by |imreconstruct|.  Notice you must 
% complement the image inputs and output of |imreconstruct|.

Iobrd = imdilate(Iobr, se);
Iobrcbr = imreconstruct(imcomplement(Iobrd), imcomplement(Iobr));
Iobrcbr = imcomplement(Iobrcbr);
figure, imshow(Iobrcbr), title('Opening-closing by reconstruction (Iobrcbr)')

%%
% As you can see by comparing |Iobrcbr| with |Ioc|, reconstruction-based
% opening and closing are more 
% effective than standard opening and closing at removing small blemishes
% without affecting the overall shapes of the objects.  Calculate the
% regional maxima of |Iobrcbr| to obtain good foreground markers.

fgm = imregionalmax(Iobrcbr);
figure, imshow(fgm), title('Regional maxima of opening-closing by reconstruction (fgm)')

%%
% To help interpret the result, superimpose the foreground marker image
% on the original image. 

I2 = I;
I2(fgm) = 255;
figure, imshow(I2), title('Regional maxima superimposed on original image (I2)')

%%
% Notice that some of the mostly-occluded and shadowed objects are not
% marked, which means that these objects will not be segmented properly
% in the end result.  Also, the foreground markers in some objects go right
% up to the objects' edge.  That means you should clean the edges of the
% marker blobs and then shrink them a bit.  You can do this by a closing
% followed by an erosion.

se2 = strel(ones(5,5));
fgm2 = imclose(fgm, se2);
fgm3 = imerode(fgm2, se2);

%%
% This procedure tends to leave some stray isolated pixels that must be
% removed.  You can do this using |bwareaopen|, which removes all blobs
% that have fewer than a certain number of pixels. 

fgm4 = bwareaopen(fgm3, 20);
I3 = I;
I3(fgm4) = 255;
figure, imshow(I3)
title('Modified regional maxima superimposed on original image (fgm4)')

%% Step 4: Compute Background Markers
% Now you need to mark the background.  In the cleaned-up image, |Iobrcbr|,
% the dark pixels belong to the background, so you could start with a
% thresholding operation.

bw = im2bw(Iobrcbr, graythresh(Iobrcbr));
figure, imshow(bw), title('Thresholded opening-closing by reconstruction (bw)')

%%
% The background pixels are in black, but ideally we don't want the
% background markers to be too close to the edges of the objects we are
% trying to segment.  We'll "thin" the background by computing the
% "skeleton by influence zones", or SKIZ, of the foreground of |bw|.
% This can be done by computing the watershed transform of the distance
% transform of |bw|, and then looking for the watershed ridge lines (|DL ==
% 0|) of the result.

D = bwdist(bw);
DL = watershed(D);
bgm = DL == 0;
figure, imshow(bgm), title('Watershed ridge lines (bgm)')

%% Step 5: Compute the Watershed Transform of the Segmentation Function.
% The function |imimposemin| can be used to modify an image so that it has 
% regional minima only in certain desired locations.  Here you can use
% |imimposemin| to modify the gradient magnitude image so that its only
% regional minima occur at foreground and background marker pixels.

gradmag2 = imimposemin(gradmag, bgm | fgm4);

%%
% Finally we are ready to compute the watershed-based segmentation.

L = watershed(gradmag2);

%% Step 6: Visualize the Result
% One visualization technique is to superimpose the foreground
% markers, background markers, and segmented object boundaries on the
% original image.  You can use dilation as needed to make certain aspects,
% such as the object boundaries, more visible.  Object boundaries are
% located where |L == 0|.

I4 = I;
I4(imdilate(L == 0, ones(3, 3)) | bgm | fgm4) = 255;
figure, imshow(I4)
title('Markers and object boundaries superimposed on original image (I4)')

%%
% This visualization illustrates how the locations of the foreground and
% background markers affect the result.  In a couple of locations,
% partially occluded darker objects were merged with their brighter
% neighbor objects because the occluded objects did not have foreground
% markers.
%
% Another useful visualization technique is to display the label matrix
% as a color image.  Label matrices, such as those produced by
% |watershed| and |bwlabel|, can be converted to truecolor images for
% visualization purposes by using |label2rgb|.

Lrgb = label2rgb(L, 'jet', 'w', 'shuffle');
figure, imshow(Lrgb)
title('Colored watershed label matrix (Lrgb)')

%%
% You can use transparency to superimpose this pseudo-color label matrix on
% top of the original intensity image.

figure, imshow(I), hold on
himage = imshow(Lrgb);
set(himage, 'AlphaData', 0.3);
title('Lrgb superimposed transparently on original image')


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>