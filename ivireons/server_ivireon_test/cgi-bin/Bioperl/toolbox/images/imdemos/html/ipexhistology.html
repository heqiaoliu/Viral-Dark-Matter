
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Color-Based Segmentation Using K-Means Clustering</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="ipexhistology.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexhistology">Open ipexhistology.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexhistology">Run in the Command Window</a></div></div><div class="content"><h1>Color-Based Segmentation Using K-Means Clustering</h1><!--introduction--><p>Your goal is to segment colors in an automated fashion using the L*a*b* color space and K-means clustering.</p><p>This demo requires Statistics Toolbox&#8482;.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Read Image</a></li><li><a href="#2">Step 2: Convert Image from RGB Color Space to L*a*b* Color Space</a></li><li><a href="#3">Step 3: Classify the Colors in 'a*b*' Space Using K-Means Clustering</a></li><li><a href="#4">Step 4: Label Every Pixel in the Image Using the Results from KMEANS</a></li><li><a href="#5">Step 5: Create Images that Segment the H&amp;E Image by Color.</a></li><li><a href="#8">Step 6: Segment the Nuclei into a Separate Image</a></li></ul></div><h2>Step 1: Read Image<a name="1"></a></h2><p>Read in <tt>hestain.png</tt>, which is an image of tissue stained with hemotoxylin and eosin (H&amp;E). This staining method helps pathologists distinguish different tissue types.</p><pre class="codeinput">he = imread(<span class="string">'hestain.png'</span>);
imshow(he), title(<span class="string">'H&amp;E image'</span>);
text(size(he,2),size(he,1)+15,<span class="keyword">...</span>
     <span class="string">'Image courtesy of Alan Partin, Johns Hopkins University'</span>, <span class="keyword">...</span>
     <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_01.png" alt=""> <h2>Step 2: Convert Image from RGB Color Space to L*a*b* Color Space<a name="2"></a></h2><p>How many colors do you see in the image if you ignore variations in brightness?  There are three colors: white, blue, and pink.  Notice how easily you can visually distinguish these colors from one another.  The L*a*b* color space (also known as CIELAB or CIE L*a*b*) enables you to quantify these visual differences.</p><p>The L*a*b* color space is derived from the CIE XYZ tristimulus values.  The L*a*b* space consists of a luminosity layer 'L*', chromaticity-layer 'a*' indicating where color falls along the red-green axis, and chromaticity-layer 'b*' indicating where the color falls along the blue-yellow axis. All of the color information is in the 'a*' and 'b*' layers. You can measure the difference between two colors using the Euclidean distance metric.</p><p>Convert the image to L*a*b* color space using <tt>makecform</tt> and <tt>applycform</tt>.</p><pre class="codeinput">cform = makecform(<span class="string">'srgb2lab'</span>);
lab_he = applycform(he,cform);
</pre><h2>Step 3: Classify the Colors in 'a*b*' Space Using K-Means Clustering<a name="3"></a></h2><p>Clustering is a way to separate groups of objects.  K-means clustering treats each object as having a location in space. It finds partitions such that objects within each cluster are as close to each other as possible, and as far from objects in other clusters as possible. K-means clustering requires that you specify the number of clusters to be partitioned and a distance metric to quantify how close two objects are to each other.</p><p>Since the color information exists in the 'a*b*' space, your objects are pixels with 'a*' and 'b*' values.  Use <tt>kmeans</tt> to cluster the objects into three clusters using the Euclidean distance metric.</p><pre class="codeinput">ab = double(lab_he(:,:,2:3));
nrows = size(ab,1);
ncols = size(ab,2);
ab = reshape(ab,nrows*ncols,2);

nColors = 3;
<span class="comment">% repeat the clustering 3 times to avoid local minima</span>
[cluster_idx cluster_center] = kmeans(ab,nColors,<span class="string">'distance'</span>,<span class="string">'sqEuclidean'</span>, <span class="keyword">...</span>
                                      <span class="string">'Replicates'</span>,3);
</pre><h2>Step 4: Label Every Pixel in the Image Using the Results from KMEANS<a name="4"></a></h2><p>For every object in your input, <tt>kmeans</tt> returns an index corresponding to a cluster. The <tt>cluster_center</tt> output from <tt>kmeans</tt> will be used later in the demo. Label every pixel in the image with its <tt>cluster_index</tt>.</p><pre class="codeinput">pixel_labels = reshape(cluster_idx,nrows,ncols);
imshow(pixel_labels,[]), title(<span class="string">'image labeled by cluster index'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_02.png" alt=""> <h2>Step 5: Create Images that Segment the H&amp;E Image by Color.<a name="5"></a></h2><p>Using <tt>pixel_labels</tt>, you can separate objects in <tt>hestain.png</tt> by color, which will result in three images.</p><pre class="codeinput">segmented_images = cell(1,3);
rgb_label = repmat(pixel_labels,[1 1 3]);

<span class="keyword">for</span> k = 1:nColors
    color = he;
    color(rgb_label ~= k) = 0;
    segmented_images{k} = color;
<span class="keyword">end</span>

imshow(segmented_images{1}), title(<span class="string">'objects in cluster 1'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_03.png" alt=""> <pre class="codeinput">imshow(segmented_images{2}), title(<span class="string">'objects in cluster 2'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_04.png" alt=""> <pre class="codeinput">imshow(segmented_images{3}), title(<span class="string">'objects in cluster 3'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_05.png" alt=""> <h2>Step 6: Segment the Nuclei into a Separate Image<a name="8"></a></h2><p>Notice that there are dark and light blue objects in one of the clusters. You can separate dark blue from light blue using the 'L*' layer in the L*a*b* color space. The cell nuclei are dark blue.</p><p>Recall that the 'L*' layer contains the brightness values of each color. Find the cluster that contains the blue objects. Extract the brightness values of the pixels in this cluster and threshold them using <tt>im2bw</tt>.</p><p>You must programmatically determine the index of the cluster containing the blue objects because <tt>kmeans</tt> will not return the same <tt>cluster_idx</tt> value every time.  You can do this using the <tt>cluster_center</tt> value, which contains the mean 'a*' and 'b*' value for each cluster. The blue cluster has the smallest cluster_center value (determined experimentally).</p><pre class="codeinput">mean_cluster_value = mean(cluster_center,2);
[tmp, idx] = sort(mean_cluster_value);
blue_cluster_num = idx(1);

L = lab_he(:,:,1);
blue_idx = find(pixel_labels == blue_cluster_num);
L_blue = L(blue_idx);
is_light_blue = im2bw(L_blue,graythresh(L_blue));
</pre><p>Use the mask <tt>is_light_blue</tt> to label which pixels belong to the blue nuclei. Then display the blue nuclei in a separate image.</p><pre class="codeinput">nuclei_labels = repmat(uint8(0),[nrows ncols]);
nuclei_labels(blue_idx(is_light_blue==false)) = 1;
nuclei_labels = repmat(nuclei_labels,[1 1 3]);
blue_nuclei = he;
blue_nuclei(nuclei_labels ~= 1) = 0;
imshow(blue_nuclei), title(<span class="string">'blue nuclei'</span>);
</pre><img vspace="5" hspace="5" src="ipexhistology_06.png" alt=""> <p class="footer">Copyright 1993-2007 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Color-Based Segmentation Using K-Means Clustering
% Your goal is to segment colors in an automated fashion using the L*a*b* color
% space and K-means clustering.
%
% This demo requires Statistics Toolbox(TM).

% Copyright 1993-2007 The MathWorks, Inc.

%% Step 1: Read Image
% Read in |hestain.png|, which is an image of tissue stained with hemotoxylin
% and eosin (H&E). This staining method helps pathologists distinguish different
% tissue types.

he = imread('hestain.png');
imshow(he), title('H&E image');
text(size(he,2),size(he,1)+15,...
     'Image courtesy of Alan Partin, Johns Hopkins University', ...
     'FontSize',7,'HorizontalAlignment','right');


%% Step 2: Convert Image from RGB Color Space to L*a*b* Color Space
% How many colors do you see in the image if you ignore variations in
% brightness?  There are three colors: white, blue, and pink.  Notice how easily
% you can visually distinguish these colors from one another.  The L*a*b* color
% space (also known as CIELAB or CIE L*a*b*) enables you to quantify these
% visual differences.
%
% The L*a*b* color space is derived from the CIE XYZ tristimulus values.  The
% L*a*b* space consists of a luminosity layer 'L*', chromaticity-layer 'a*'
% indicating where color falls along the red-green axis, and chromaticity-layer
% 'b*' indicating where the color falls along the blue-yellow axis. All of the
% color information is in the 'a*' and 'b*' layers. You can measure the
% difference between two colors using the Euclidean distance metric.
%
% Convert the image to L*a*b* color space using |makecform| and |applycform|.

cform = makecform('srgb2lab');
lab_he = applycform(he,cform);

%% Step 3: Classify the Colors in 'a*b*' Space Using K-Means Clustering
% Clustering is a way to separate groups of objects.  K-means clustering treats
% each object as having a location in space. It finds partitions such that
% objects within each cluster are as close to each other as possible, and as far
% from objects in other clusters as possible. K-means clustering requires that
% you specify the number of clusters to be partitioned and a distance metric to
% quantify how close two objects are to each other.
%
% Since the color information exists in the 'a*b*' space, your objects are
% pixels with 'a*' and 'b*' values.  Use |kmeans| to cluster the objects into
% three clusters using the Euclidean distance metric.

ab = double(lab_he(:,:,2:3));
nrows = size(ab,1);
ncols = size(ab,2);
ab = reshape(ab,nrows*ncols,2);

nColors = 3;
% repeat the clustering 3 times to avoid local minima
[cluster_idx cluster_center] = kmeans(ab,nColors,'distance','sqEuclidean', ...
                                      'Replicates',3);

%% Step 4: Label Every Pixel in the Image Using the Results from KMEANS
% For every object in your input, |kmeans| returns an index corresponding to a
% cluster. The |cluster_center| output from |kmeans| will be used later in the
% demo. Label every pixel in the image with its |cluster_index|.

pixel_labels = reshape(cluster_idx,nrows,ncols);
imshow(pixel_labels,[]), title('image labeled by cluster index');

%% Step 5: Create Images that Segment the H&E Image by Color.
% Using |pixel_labels|, you can separate objects in |hestain.png| by color,
% which will result in three images.

segmented_images = cell(1,3);
rgb_label = repmat(pixel_labels,[1 1 3]);

for k = 1:nColors
    color = he;
    color(rgb_label ~= k) = 0;
    segmented_images{k} = color;
end

imshow(segmented_images{1}), title('objects in cluster 1');

%% 

imshow(segmented_images{2}), title('objects in cluster 2');

%% 

imshow(segmented_images{3}), title('objects in cluster 3');

%% Step 6: Segment the Nuclei into a Separate Image
% Notice that there are dark and light blue objects in one of the clusters.
% You can separate dark blue from light blue using the 'L*' layer in the
% L*a*b* color space. The cell nuclei are dark blue.
%
% Recall that the 'L*' layer contains the brightness values of each color.
% Find the cluster that contains the blue objects. Extract the brightness
% values of the pixels in this cluster and threshold them using |im2bw|.
%
% You must programmatically determine the index of the cluster containing
% the blue objects because |kmeans| will not return the same |cluster_idx|
% value every time.  You can do this using the |cluster_center| value,
% which contains the mean 'a*' and 'b*' value for each cluster. The blue
% cluster has the smallest cluster_center value (determined
% experimentally).
mean_cluster_value = mean(cluster_center,2);
[tmp, idx] = sort(mean_cluster_value);
blue_cluster_num = idx(1);

L = lab_he(:,:,1);
blue_idx = find(pixel_labels == blue_cluster_num);
L_blue = L(blue_idx);
is_light_blue = im2bw(L_blue,graythresh(L_blue));

%%
% Use the mask |is_light_blue| to label which pixels belong to the blue
% nuclei. Then display the blue nuclei in a separate image.

nuclei_labels = repmat(uint8(0),[nrows ncols]);
nuclei_labels(blue_idx(is_light_blue==false)) = 1;
nuclei_labels = repmat(nuclei_labels,[1 1 3]);
blue_nuclei = he;
blue_nuclei(nuclei_labels ~= 1) = 0;
imshow(blue_nuclei), title('blue nuclei');


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>