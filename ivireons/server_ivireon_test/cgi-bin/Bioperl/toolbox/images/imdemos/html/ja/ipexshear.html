
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>イメージの付加と剪断の同時実行</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexshear.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexshear">エディターで ipexshear.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexshear">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>イメージの付加と剪断の同時実行</h1><!--introduction--><p>このデモでは、簡単な剪断の変換を表す <tt>tform</tt> 構造体を作成し、イメージに適用します。変換が直線と円にどのような影響を与えるかを調査し、その後、<tt>imtransform</tt> および <tt>tformarray</tt> と併用できるイメージ付加に対するさまざまなオプションを調査するための手段としてそれを使用します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: 簡単な剪断を使用したイメージの変換</a></li><li><a href="#6">手順 2: 変換の探求</a></li><li><a href="#8">手順 3: 付加手法 'fill'、'replicate'、および 'bound' の比較</a></li><li><a href="#12">手順 4: 付加手法 'circular' および 'symmetric' の実行</a></li></ul></div><h2>手順 1: 簡単な剪断を使用したイメージの変換<a name="1"></a></h2><p>2 次元では、入力座標 <tt>[u v]</tt> のペアを出力座標 <tt>[x y]</tt> のペアにマッピングする簡単な剪断変換は、</p><p><img src="../ipexshear_eq66717.png" alt="$$x = u + a * v$$"></p><p><img src="../ipexshear_eq75711.png" alt="$$y = v$$"></p><p>という形をとります。ここで <tt>a</tt> は定数です。</p><p>簡単な剪断は、アフィン変換の特殊なケースです。以下の</p><p><img src="../ipexshear_eq55900.png" alt="$$[\begin{array}{c c}x\ y\ 1\end{array}] = [\begin{array}{c c}u\ v\ 1\end{array}] * \left[\begin{array}{c c c}1\;0\;0\\a\;1\;0\\0\;0\;1\end{array}\right]$$"></p><p>が、最初の 2 つの方程式から得た <tt>x</tt> および <tt>y</tt> の値を出力するかどうかは、簡単に確認できます。</p><p><tt>a</tt> = 0.45 に設定し <tt>maketform</tt> を使用してアフィン <tt>tform</tt> 構造体を作成します。</p><pre class="codeinput">a = 0.45;
T = maketform(<span class="string">'affine'</span>, [1 0 0; a 1 0; 0 0 1] );
</pre><p>変換するイメージを選択し、読み込み、表示します。</p><pre class="codeinput">A = imread(<span class="string">'football.jpg'</span>);
h1 = figure; imshow(A); title(<span class="string">'Original Image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_01.png" alt=""> <p>塗りつぶし値としてオレンジの陰影を選択します。</p><pre class="codeinput">orange = [255 127 0]';
</pre><p><tt>T</tt> を使用して <tt>A</tt> を変換する用意ができました。<tt>imtransform</tt> を以下のようにして呼び出すこともできました。</p><p>B = imtransform(A,T,'cubic','FillValues',orange);</p><p>ただし、行と列両方に三次補間を適用するため、この処理は無駄です (純粋な剪断変換では、各行への補間のみが必要です)。その代わり、行に三次補間を適用して、列には単に最近傍補間を使用するリサンプリング方法を作成および使用し、<tt>imtransform</tt> を呼び出して結果を表示します。</p><pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'fill'</span>);
B = imtransform(A,T,R,<span class="string">'FillValues'</span>,orange);
h2 = figure; imshow(B);
title(<span class="string">'Sheared Image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_02.png" alt=""> <h2>手順 2: 変換の探求<a name="6"></a></h2><p>直線グリッドまたは円配列を関数 <tt>tformfwd</tt> で変換するのは、変換を理解するために良い方法です (フォワード関数および逆関数がある限り)。</p><p>オリジナル イメージを覆う線のグリッドを定義し、それをイメージ上に表示します。次に関数 <tt>tformfwd</tt> を使用して、グリッドの各線に純粋な剪断を適用し、剪断されたイメージ上に結果を表示します。</p><pre class="codeinput">[U,V] = meshgrid(0:64:320,0:64:256);
[X,Y] = tformfwd(T,U,V);
gray = 0.65 * [1 1 1];

figure(h1);
hold <span class="string">on</span>;
line(U, V, <span class="string">'Color'</span>,gray);
line(U',V',<span class="string">'Color'</span>,gray);

figure(h2);
hold <span class="string">on</span>;
line(X, Y, <span class="string">'Color'</span>,gray);
line(X',Y',<span class="string">'Color'</span>,gray);
</pre><img vspace="5" hspace="5" src="../ipexshear_03.png" alt=""> <img vspace="5" hspace="5" src="../ipexshear_04.png" alt=""> <p>円の配列でも同様に実行できます。</p><pre class="codeinput">gray = 0.65 * [1 1 1];
<span class="keyword">for</span> u = 0:64:320
    <span class="keyword">for</span> v = 0:64:256
        theta = (0 : 32)' * (2 * pi / 32);
        uc = u + 20*cos(theta);
        vc = v + 20*sin(theta);
        [xc,yc] = tformfwd(T,uc,vc);
        figure(h1); line(uc,vc,<span class="string">'Color'</span>,gray);
        figure(h2); line(xc,yc,<span class="string">'Color'</span>,gray);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../ipexshear_05.png" alt=""> <img vspace="5" hspace="5" src="../ipexshear_06.png" alt=""> <h2>手順 3: 付加手法 'fill'、'replicate'、および 'bound' の比較<a name="8"></a></h2><p>剪断変換の適用時、関数 <tt>imtransform</tt> は、データのないオレンジ色の三角形を左から右に塗りつぶしました。それは、関数 <tt>makeresampler</tt> の呼び出し時に付加手法 <tt>'fill'</tt> を指定したからです。付加手法には、合計 5 つの選択肢があります (<tt>'fill'</tt>、<tt>'replicate'</tt>、<tt>'bound'</tt>、<tt>'circular'</tt>、および <tt>'symmetric'</tt>)。ここでは、最初の 3 つを比較してみます。</p><p>まずオプション <tt>'fill'</tt> の機能を理解するために、<tt>imtransform</tt> のオプション <tt>'XData'</tt> および <tt>'YData'</tt> を使用して、出力イメージに強制的に空間を追加します。</p><pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'fill'</span>);

Bf = imtransform(A,T,R,<span class="string">'XData'</span>,[-49 500],<span class="string">'YData'</span>,[-49 400],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);

figure, imshow(Bf);
title(<span class="string">'Pad Method = ''fill'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_07.png" alt=""> <p>ここでメソッド <tt>'replicate'</tt> (この場合は塗りつぶし値を指定する必要なし) を実行します。</p><pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'replicate'</span>);
Br = imtransform(A,T,R,<span class="string">'XData'</span>,[-49 500],<span class="string">'YData'</span>, [-49 400]);

figure, imshow(Br);
title(<span class="string">'Pad Method = ''replicate'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_08.png" alt=""> <p>さらにメソッド <tt>'bound'</tt> を試行します。</p><pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>}, <span class="string">'bound'</span>);
Bb = imtransform(A,T,R,<span class="string">'XData'</span>,[-49 500],<span class="string">'YData'</span>,[-49 400],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);
figure, imshow(Bb);
title(<span class="string">'Pad Method = ''bound'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_09.png" alt=""> <p><tt>'fill'</tt> および <tt>'bound'</tt> の結果は同じように見えますが、よく見ると <tt>'fill'</tt> の方がエッジが滑らかなことに気が付きます。これは、入力イメージに塗りつぶし値が付加され、三次補間がエッジ、埋め込み値、およびイメージ値全体に適用されたからです。それと比較して、メソッド <tt>'bound'</tt> は入力イメージの内側と外側を厳密に区別します。外側のポイントは塗りつぶされます。内側のポイントは、エッジに近い場合、反復を利用して補間されます。近くで見ると、より明確に表示することができます。<tt>XData</tt> および <tt>YData</tt> を選択してイメージの右下隅に近いポイントを囲み、出力イメージ空間で <tt>'nearest'</tt> を使用してリサイズし、各ピクセルの表示方法を保存します。</p><pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'fill'</span>);
Cf = imtransform(A,T,R,<span class="string">'XData'</span>,[423 439],<span class="string">'YData'</span>,[245 260],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);

R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'bound'</span>);
Cb = imtransform(A,T,R,<span class="string">'XData'</span>,[423 439],<span class="string">'YData'</span>,[245 260],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);

Cf = imresize(Cf,12,<span class="string">'nearest'</span>);
Cb = imresize(Cb,12,<span class="string">'nearest'</span>);

figure;
subplot(1,2,1); imshow(Cf); title(<span class="string">'Pad Method = ''fill'''</span>);
subplot(1,2,2); imshow(Cb); title(<span class="string">'Pad Method = ''bound'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_10.png" alt=""> <h2>手順 4: 付加手法 'circular' および 'symmetric' の実行<a name="12"></a></h2><p>残りの 2 つの付加手法は、<tt>'circular'</tt> (各次元での巡回的な繰り返し) および <tt>'symmetric'</tt> (付加された鏡像とのイメージの巡回的な繰り返し) です。発生するパターンをより多く示すため、変換を再定義してスケールを半分にします。</p><pre class="codeinput">Thalf = maketform(<span class="string">'affine'</span>,[1 0; a 1; 0 0]/2);

R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'circular'</span>);
Bc = imtransform(A,Thalf,R,<span class="string">'XData'</span>,[-49 500],<span class="string">'YData'</span>,[-49 400],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);
figure, imshow(Bc);
title(<span class="string">'Pad Method = ''circular'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_11.png" alt=""> <pre class="codeinput">R = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'symmetric'</span>);
Bs = imtransform(A,Thalf,R,<span class="string">'XData'</span>,[-49 500],<span class="string">'YData'</span>,[-49 400],<span class="keyword">...</span>
                 <span class="string">'FillValues'</span>,orange);
figure, imshow(Bs);
title(<span class="string">'Pad Method = ''symmetric'''</span>);
</pre><img vspace="5" hspace="5" src="../ipexshear_12.png" alt=""> <p class="footer">Copyright 1993-2006 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Padding and Shearing an Image Simultaneously % In this demonstration, we construct a |tform| struct that represents a % simple shear transformation, then apply it to an image. We explore how % the transformation affects straight lines and circles, and then use it as % a vehicle to explore the various options for image padding that can be % used with |imtransform| and |tformarray|.  % % Copyright 1993-2006 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $ $Date: 2010/07/29 21:28:50 $  %% Step 1: Transform an Image Using Simple Shear  % In two dimensions, a simple shear transformation that maps a pair of % input coordinates |[u v]| to a pair of output coordinates |[x y]| has the form %  % $$x = u + a * v$$ %  %  % $$y = v$$ %  % % where |a| is a constant. % % Any simple shear is a special case of an affine transformation. You can % easily verify that %  % $$[\begin{array}{c c}x\ y\ 1\end{array}] = [\begin{array}{c c}u\ v\ 1\end{array}] * \left[\begin{array}{c c c}1\;0\;0\\a\;1\;0\\0\;0\;1\end{array}\right]$$ %  % yields the values for |x| and |y| that you received from the first two equations.  %% % Setting |a| = 0.45, we construct an affine |tform| struct using % |maketform|.  a = 0.45; T = maketform('affine', [1 0 0; a 1 0; 0 0 1] );  %% % We select, read, and view and image to transform.  A = imread('football.jpg'); h1 = figure; imshow(A); title('Original Image');  %% % We choose a shade of orange as our fill value.  orange = [255 127 0]';  %% % We are ready to use |T| to transform |A|. We could call |imtransform| as follows: % % B = imtransform(A,T,'cubic','FillValues',orange); % % but this is wasteful since we would apply cubic interpolation along both % columns and rows. (With our pure shear transform, we really only need to % interpolate along each row.) Instead, we create and use a resampler that % applies cubic interpolation along the rows but simply uses nearest % neighbor interpolation along the columns, then call |imtransform| and display the result.  R = makeresampler({'cubic','nearest'},'fill'); B = imtransform(A,T,R,'FillValues',orange); h2 = figure; imshow(B); title('Sheared Image');  %% Step 2: Explore the Transformation % Transforming a grid of straight lines or an array of circles with % |tformfwd| is a good way to understand a transformation (as long as it has % both forward and inverse functions). % % Define a grid of lines covering the original image, and % display it over the image  Then use |tformfwd| to apply the pure shear to % each line in the grid, and display the result over the sheared image.  [U,V] = meshgrid(0:64:320,0:64:256); [X,Y] = tformfwd(T,U,V); gray = 0.65 * [1 1 1];  figure(h1); hold on; line(U, V, 'Color',gray); line(U',V','Color',gray);  figure(h2); hold on; line(X, Y, 'Color',gray); line(X',Y','Color',gray);  %% % You can do the same thing with an array of circles.   gray = 0.65 * [1 1 1]; for u = 0:64:320     for v = 0:64:256         theta = (0 : 32)' * (2 * pi / 32);         uc = u + 20*cos(theta);         vc = v + 20*sin(theta);         [xc,yc] = tformfwd(T,uc,vc);         figure(h1); line(uc,vc,'Color',gray);         figure(h2); line(xc,yc,'Color',gray);     end end  %% Step 3: Compare the 'fill', 'replicate', and 'bound' Pad Methods % When we applied the shear transformation, |imtransform| filled in the % orange triangles to the left and right, where there was no data. That's % because we specified a pad method of |'fill'| when calling |makeresampler|. % There are a total of five different pad method choices (|'fill'|, % |'replicate'|, |'bound'|, |'circular'|, and |'symmetric'|). Here we compare the first three. % % First, to get a better look at how the |'fill'| option worked, use the % |'XData'| and |'YData'| options in |imtransform| to force some additional space % around the output image.  R = makeresampler({'cubic','nearest'},'fill');  Bf = imtransform(A,T,R,'XData',[-49 500],'YData',[-49 400],...                  'FillValues',orange);  figure, imshow(Bf); title('Pad Method = ''fill''');  %% % Now, try the |'replicate'| method (no need to specify fill values in this % case).  R = makeresampler({'cubic','nearest'},'replicate'); Br = imtransform(A,T,R,'XData',[-49 500],'YData', [-49 400]);  figure, imshow(Br); title('Pad Method = ''replicate''');  %% % And try the |'bound'| method.  R = makeresampler({'cubic','nearest'}, 'bound'); Bb = imtransform(A,T,R,'XData',[-49 500],'YData',[-49 400],...                  'FillValues',orange); figure, imshow(Bb); title('Pad Method = ''bound''');  %% % Results with |'fill'| and |'bound'| look very similar, but look closely and % you'll see that the edges are smoother with |'fill'|. That's because the % input image is padded with the fill values, then the cubic interpolation % is applied across the edge, mixing fill and image values. In contrast, % |'bound'| recognizes a strict boundary between the inside and outside of % the input image. Points falling outside are filled. Points falling inside % are interpolated, using replication when they're near the edge. A close % up look helps show this more clearly. We choose |XData| and |YData| to % bracket a point near the lower right corner of the image, in the output % image space, the resize with |'nearest'| to preserve the appearance of % the individual pixels.  R = makeresampler({'cubic','nearest'},'fill'); Cf = imtransform(A,T,R,'XData',[423 439],'YData',[245 260],...                  'FillValues',orange);  R = makeresampler({'cubic','nearest'},'bound'); Cb = imtransform(A,T,R,'XData',[423 439],'YData',[245 260],...                  'FillValues',orange);  Cf = imresize(Cf,12,'nearest'); Cb = imresize(Cb,12,'nearest');  figure; subplot(1,2,1); imshow(Cf); title('Pad Method = ''fill'''); subplot(1,2,2); imshow(Cb); title('Pad Method = ''bound''');  %% Step 4: Exercise the 'circular' and 'symmetric' Pad Methods % The remaining two pad methods are |'circular'| (circular repetition in each % dimension) and |'symmetric'| (circular repetition of the image with an % appended mirror image). To show more of the pattern that emerges, we % redefine the transformation to cut the scale in half.  Thalf = maketform('affine',[1 0; a 1; 0 0]/2);  R = makeresampler({'cubic','nearest'},'circular'); Bc = imtransform(A,Thalf,R,'XData',[-49 500],'YData',[-49 400],...                  'FillValues',orange); figure, imshow(Bc); title('Pad Method = ''circular''');  %%  R = makeresampler({'cubic','nearest'},'symmetric'); Bs = imtransform(A,Thalf,R,'XData',[-49 500],'YData',[-49 400],...                  'FillValues',orange); figure, imshow(Bs); title('Pad Method = ''symmetric''');   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>