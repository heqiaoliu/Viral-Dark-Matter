
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Finding the Length of a Pendulum in Motion</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="ipexpendulum.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexpendulum">Open ipexpendulum.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexpendulum">Run in the Command Window</a></div></div><div class="content"><h1>Finding the Length of a Pendulum in Motion</h1><!--introduction--><p>You can capture images in a time series with the Image Acquisition Toolbox&#8482; and analyze them with the Image Processing Toolbox&#8482;. This demo shows you how to calculate the length of a pendulum in motion.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Acquire Images</a></li><li><a href="#2">Step 2: Explore Sequence with IMPLAY</a></li><li><a href="#3">Step 3: Select Region where Pendulum is Swinging</a></li><li><a href="#5">Step 4: Segment the Pendulum in Each Frame</a></li><li><a href="#6">Step 5: Find the Center of the Segmented Pendulum in Each Frame</a></li><li><a href="#9">Step 6: Calculate Radius by Fitting a Circle Through Pendulum Centers</a></li></ul></div><h2>Step 1: Acquire Images<a name="1"></a></h2><p>Load the image frames of a pendulum in motion. The frames in the MAT-file <tt>pendulum.mat</tt> were acquired using the following functions in the Image Acquisition Toolbox.</p><pre class="codeinput"><span class="comment">% Access an image acquisition device (video object).</span>
<span class="comment">% vidobj=videoinput('winvideo',1,'RGB24_352x288');</span>

<span class="comment">% Configure object to capture every fifth frame.</span>
<span class="comment">% set(vidobj,'FrameGrabInterval',5);</span>

<span class="comment">% Configure the number of frames to be logged.</span>
<span class="comment">% nFrames=50;</span>
<span class="comment">% set(vidobj,'FramesPerTrigger',nFrames);</span>

<span class="comment">% Access the device's video source.</span>
<span class="comment">% src=getselectedsource(vidobj);</span>

<span class="comment">% Configure device to provide thirty frames per second.</span>
<span class="comment">% set(src,'FrameRate','30');</span>

<span class="comment">% Open a live preview window. Focus camera onto a moving pendulum.</span>
<span class="comment">% preview(vidobj);</span>

<span class="comment">% Initiate the acquisition.</span>
<span class="comment">% start(vidobj);</span>

<span class="comment">% Wait for data logging to finish before retrieving the data.</span>
<span class="comment">% wait(vidobj, 10);</span>

<span class="comment">% Extract frames from memory.</span>
<span class="comment">% frames = getdata(vidobj);</span>

<span class="comment">% Clean up. Delete and clear associated variables.</span>
<span class="comment">% delete(vidobj)</span>
<span class="comment">% clear vidobj</span>

<span class="comment">%load MAT-file</span>

load <span class="string">pendulum</span>;
</pre><h2>Step 2: Explore Sequence with IMPLAY<a name="2"></a></h2><p>Run the following command to explore the image sequence in <tt>implay</tt>.</p><pre class="codeinput">implay(frames);
</pre><img vspace="5" hspace="5" src="ipexpendulum_01.png" alt=""> <h2>Step 3: Select Region where Pendulum is Swinging<a name="3"></a></h2><p>You can see that the pendulum is swinging in the upper half of each frame in the image series.  Create a new series of frames that contains only the region where the pendulum is swinging.</p><p>To crop a series of frames using <tt>imcrop</tt>, first perform <tt>imcrop</tt> on one frame and store its output image. Then use the previous output's size to create a series of frame regions.  For convenience, use the <tt>rect</tt> that was loaded by <tt>pendulum.mat</tt> in <tt>imcrop</tt>.</p><pre class="codeinput">nFrames = size(frames,4);
first_frame = frames(:,:,:,1);
first_region = imcrop(first_frame,rect);
frame_regions = repmat(uint8(0), [size(first_region) nFrames]);
<span class="keyword">for</span> count = 1:nFrames
  frame_regions(:,:,:,count) = imcrop(frames(:,:,:,count),rect);
<span class="keyword">end</span>
imshow(frames(:,:,:,1))
</pre><img vspace="5" hspace="5" src="ipexpendulum_02.png" alt=""> <pre class="codeinput">imshow(frame_regions(:,:,:,1));
</pre><img vspace="5" hspace="5" src="ipexpendulum_03.png" alt=""> <h2>Step 4: Segment the Pendulum in Each Frame<a name="5"></a></h2><p>Notice that the pendulum is much darker than the background.  You can segment the pendulum in each frame by converting the frame to grayscale, thresholding it using <tt>im2bw</tt>, and removing background structures using <tt>imopen</tt> and <tt>imclearborder</tt>.</p><pre class="codeinput"><span class="comment">% initialize array to contain the segmented pendulum frames.</span>
seg_pend = false([size(first_region,1) size(first_region,2) nFrames]);
centroids = zeros(nFrames,2);
se_disk = strel(<span class="string">'disk'</span>,3);

<span class="keyword">for</span> count = 1:nFrames
    fr = frame_regions(:,:,:,count);
    imshow(fr)
    pause(0.2)

    gfr = rgb2gray(fr);
    gfr = imcomplement(gfr);
    imshow(gfr)
    pause(0.2)

    bw = im2bw(gfr,.7);  <span class="comment">% threshold is determined experimentally</span>
    bw = imopen(bw,se_disk);
    bw = imclearborder(bw);
    seg_pend(:,:,count) = bw;
    imshow(bw)
    pause(0.2)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="ipexpendulum_04.png" alt=""> <h2>Step 5: Find the Center of the Segmented Pendulum in Each Frame<a name="6"></a></h2><p>You can see that the shape of the pendulum varied in different frames. This is not a serious issue because you just need its center. You will use the pendulum centers to find the length of the pendulum.</p><p>Use <tt>regionprops</tt> to calculate the center of the pendulum.</p><pre class="codeinput">pend_centers = zeros(nFrames,2);
<span class="keyword">for</span> count = 1:nFrames
    property = regionprops(seg_pend(:,:,count), <span class="string">'Centroid'</span>);
    pend_centers(count,:) = property.Centroid;
<span class="keyword">end</span>
</pre><p>Display pendulum centers using <tt>plot</tt>.</p><pre class="codeinput">x = pend_centers(:,1);
y = pend_centers(:,2);
figure
plot(x,y,<span class="string">'m.'</span>), axis <span class="string">ij</span>, axis <span class="string">equal</span>, hold <span class="string">on</span>;
xlabel(<span class="string">'x'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'pendulum centers'</span>);
</pre><img vspace="5" hspace="5" src="ipexpendulum_05.png" alt=""> <h2>Step 6: Calculate Radius by Fitting a Circle Through Pendulum Centers<a name="9"></a></h2><p>Rewrite the basic equation of a circle:</p><p><tt>(x-xc)^2 + (y-yc)^2 = radius^2</tt></p><p>where <tt>(xc,yc)</tt> is the center, in terms of parameters <tt>a</tt>, <tt>b</tt>, <tt>c</tt> as</p><p><tt>x^2 + y^2 + a*x + b*y + c = 0</tt></p><p>where <tt>a = -2*xc</tt>, <tt>b = -2*yc</tt>, and <tt>c = xc^2 + yc^2 - radius^2</tt>.</p><p>You can solve for parameters <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> using the least squares method. Rewrite the above equation as</p><p><tt>a*x + b*y + c = -(x^2 + y^2)</tt></p><p>which can also be rewritten as</p><p><tt>[x y 1] * [a;b;c] = -x^2 - y^2</tt>.</p><p>Solve this equation using the backslash(<tt>\</tt>) operator.</p><p>The circle radius is the length of the pendulum in pixels.</p><pre class="codeinput">abc = [x y ones(length(x),1)] \ -(x.^2 + y.^2);
a = abc(1); b = abc(2); c = abc(3);
xc = -a/2;
yc = -b/2;
circle_radius = sqrt((xc^2 + yc^2) - c);
pendulum_length = round(circle_radius)
</pre><pre class="codeoutput">
pendulum_length =

   253

</pre><p>Superimpose circle and circle center on the plot of pendulum centers.</p><pre class="codeinput">circle_theta = pi/3:0.01:pi*2/3;
x_fit = circle_radius*cos(circle_theta)+xc;
y_fit = circle_radius*sin(circle_theta)+yc;

plot(x_fit,y_fit,<span class="string">'b-'</span>);
plot(xc,yc,<span class="string">'bx'</span>,<span class="string">'LineWidth'</span>,2);
plot([xc x(1)],[yc y(1)],<span class="string">'b-'</span>);
text(xc-110,yc+100,sprintf(<span class="string">'pendulum length = %d pixels'</span>, pendulum_length));
</pre><img vspace="5" hspace="5" src="ipexpendulum_06.png" alt=""> <p class="footer">Copyright 1993-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Finding the Length of a Pendulum in Motion
% You can capture images in a time series with the Image Acquisition
% Toolbox(TM) and analyze them with the Image Processing Toolbox(TM). This
% demo shows you how to calculate the length of a pendulum in motion.

% Copyright 1993-2010 The MathWorks, Inc.

%% Step 1: Acquire Images
% Load the image frames of a pendulum in motion. The frames in the MAT-file
% |pendulum.mat| were acquired using the following functions in the Image
% Acquisition Toolbox.

% Access an image acquisition device (video object).
% vidobj=videoinput('winvideo',1,'RGB24_352x288');

% Configure object to capture every fifth frame.
% set(vidobj,'FrameGrabInterval',5);

% Configure the number of frames to be logged.
% nFrames=50;
% set(vidobj,'FramesPerTrigger',nFrames);

% Access the device's video source.
% src=getselectedsource(vidobj);

% Configure device to provide thirty frames per second.
% set(src,'FrameRate','30');

% Open a live preview window. Focus camera onto a moving pendulum.
% preview(vidobj);

% Initiate the acquisition.
% start(vidobj);

% Wait for data logging to finish before retrieving the data.
% wait(vidobj, 10);

% Extract frames from memory.
% frames = getdata(vidobj);

% Clean up. Delete and clear associated variables.
% delete(vidobj)
% clear vidobj

%load MAT-file

load pendulum;

%% Step 2: Explore Sequence with IMPLAY
% Run the following command to explore the image sequence in |implay|.

implay(frames);

%% Step 3: Select Region where Pendulum is Swinging
% You can see that the pendulum is swinging in the upper half of each frame
% in the image series.  Create a new series of frames that contains only
% the region where the pendulum is swinging.
%
% To crop a series of frames using |imcrop|, first perform |imcrop| on one
% frame and store its output image. Then use the previous output's size to
% create a series of frame regions.  For convenience, use the |rect| that
% was loaded by |pendulum.mat| in |imcrop|.

nFrames = size(frames,4);
first_frame = frames(:,:,:,1);
first_region = imcrop(first_frame,rect);
frame_regions = repmat(uint8(0), [size(first_region) nFrames]);
for count = 1:nFrames
  frame_regions(:,:,:,count) = imcrop(frames(:,:,:,count),rect);
end
imshow(frames(:,:,:,1))

%%
imshow(frame_regions(:,:,:,1));

%% Step 4: Segment the Pendulum in Each Frame
% Notice that the pendulum is much darker than the background.  You can
% segment the pendulum in each frame by converting the frame to grayscale,
% thresholding it using |im2bw|, and removing background structures using
% |imopen| and |imclearborder|.

% initialize array to contain the segmented pendulum frames.
seg_pend = false([size(first_region,1) size(first_region,2) nFrames]);
centroids = zeros(nFrames,2);
se_disk = strel('disk',3);

for count = 1:nFrames
    fr = frame_regions(:,:,:,count);
    imshow(fr)
    pause(0.2)
    
    gfr = rgb2gray(fr);
    gfr = imcomplement(gfr);
    imshow(gfr)
    pause(0.2)
    
    bw = im2bw(gfr,.7);  % threshold is determined experimentally 
    bw = imopen(bw,se_disk);
    bw = imclearborder(bw);
    seg_pend(:,:,count) = bw;
    imshow(bw)
    pause(0.2)
end

%% Step 5: Find the Center of the Segmented Pendulum in Each Frame
% You can see that the shape of the pendulum varied in different frames.
% This is not a serious issue because you just need its center. You will
% use the pendulum centers to find the length of the pendulum.

%%
% Use |regionprops| to calculate the center of the pendulum.
pend_centers = zeros(nFrames,2);
for count = 1:nFrames
    property = regionprops(seg_pend(:,:,count), 'Centroid');
    pend_centers(count,:) = property.Centroid; 
end

%%
% Display pendulum centers using |plot|.

x = pend_centers(:,1);
y = pend_centers(:,2);
figure
plot(x,y,'m.'), axis ij, axis equal, hold on;
xlabel('x');
ylabel('y');
title('pendulum centers');

%% Step 6: Calculate Radius by Fitting a Circle Through Pendulum Centers
% Rewrite the basic equation of a circle: 
%
% |(x-xc)^2 + (y-yc)^2 = radius^2|
%
% where |(xc,yc)| is the center, in terms of parameters |a|, |b|, |c| as
%
% |x^2 + y^2 + a*x + b*y + c = 0|
%
% where |a = -2*xc|, |b = -2*yc|, and |c = xc^2 + yc^2 - radius^2|.
%
% You can solve for parameters |a|, |b|, and |c| using the least squares
% method. Rewrite the above equation as 
%
% |a*x + b*y + c = -(x^2 + y^2)|
%
% which can also be rewritten as 
%
% |[x y 1] * [a;b;c] = -x^2 - y^2|.  
%
% Solve this equation using the backslash(|\|) operator.
%
% The circle radius is the length of the pendulum in pixels.

abc = [x y ones(length(x),1)] \ -(x.^2 + y.^2);
a = abc(1); b = abc(2); c = abc(3);
xc = -a/2;
yc = -b/2;
circle_radius = sqrt((xc^2 + yc^2) - c); 
pendulum_length = round(circle_radius)

%%
% Superimpose circle and circle center on the plot of pendulum centers.

circle_theta = pi/3:0.01:pi*2/3;
x_fit = circle_radius*cos(circle_theta)+xc;
y_fit = circle_radius*sin(circle_theta)+yc;

plot(x_fit,y_fit,'b-');
plot(xc,yc,'bx','LineWidth',2);
plot([xc x(1)],[yc y(1)],'b-');
text(xc-110,yc+100,sprintf('pendulum length = %d pixels', pendulum_length));

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>