
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Deblurring Images Using the Blind Deconvolution Algorithm</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="ipexblind.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexblind">Open ipexblind.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexblind">Run in the Command Window</a></div></div><div class="content"><h1>Deblurring Images Using the Blind Deconvolution Algorithm</h1><!--introduction--><p>The Blind Deconvolution Algorithm can be used effectively when no information about the distortion (blurring and noise) is known. The algorithm restores the image and the point-spread function (PSF) simultaneously. The accelerated, damped Richardson-Lucy algorithm is used in each iteration. Additional optical system (e.g. camera) characteristics can be used as input parameters that could help to improve the quality of the image restoration. PSF constraints can be passed in through a user-specified function</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Read Image</a></li><li><a href="#2">Step 2: Simulate a Blur</a></li><li><a href="#3">Step 3: Restore the Blurred Image Using PSFs of Various Sizes</a></li><li><a href="#7">Step 4: Analyzing the Restored PSF</a></li><li><a href="#11">Step 5: Improving the Restoration</a></li><li><a href="#15">Step 6: Using Additional Constraints on the PSF Restoration</a></li></ul></div><h2>Step 1: Read Image<a name="1"></a></h2><p>The example reads in an intensity image. The <tt>deconvblind</tt> function can handle arrays of any dimension.</p><pre class="codeinput">I = imread(<span class="string">'cameraman.tif'</span>);
figure;imshow(I);title(<span class="string">'Original Image'</span>);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of Massachusetts Institute of Technology'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_01.png" alt=""> <h2>Step 2: Simulate a Blur<a name="2"></a></h2><p>Simulate a real-life image that could be blurred (e.g., due to camera motion or lack of focus). The example simulates the blur by convolving a Gaussian filter with the true image (using <tt>imfilter</tt>). The Gaussian filter then represents a point-spread function, <tt>PSF</tt>.</p><pre class="codeinput">PSF = fspecial(<span class="string">'gaussian'</span>,7,10);
Blurred = imfilter(I,PSF,<span class="string">'symmetric'</span>,<span class="string">'conv'</span>);
figure;imshow(Blurred);title(<span class="string">'Blurred Image'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_02.png" alt=""> <h2>Step 3: Restore the Blurred Image Using PSFs of Various Sizes<a name="3"></a></h2><p>To illustrate the importance of knowing the size of the true PSF, this example performs three restorations. Each time the PSF reconstruction starts from a uniform array--an array of ones.</p><p>The first restoration, <tt>J1</tt> and <tt>P1</tt>, uses an undersized array, <tt>UNDERPSF</tt>, for an initial guess of the PSF. The size of the UNDERPSF array is 4 pixels shorter in each dimension than the true PSF.</p><pre class="codeinput">UNDERPSF = ones(size(PSF)-4);
[J1 P1] = deconvblind(Blurred,UNDERPSF);
figure;imshow(J1);title(<span class="string">'Deblurring with Undersized PSF'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_03.png" alt=""> <p>The second restoration, <tt>J2</tt> and <tt>P2</tt>, uses an array of ones, <tt>OVERPSF</tt>, for an initial PSF that is 4 pixels longer in each dimension than the true PSF.</p><pre class="codeinput">OVERPSF = padarray(UNDERPSF,[4 4],<span class="string">'replicate'</span>,<span class="string">'both'</span>);
[J2 P2] = deconvblind(Blurred,OVERPSF);
figure;imshow(J2);title(<span class="string">'Deblurring with Oversized PSF'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_04.png" alt=""> <p>The third restoration, <tt>J3</tt> and <tt>P3</tt>, uses an array of ones, <tt>INITPSF</tt>, for an initial PSF that is exactly of the same size as the true PSF.</p><pre class="codeinput">INITPSF = padarray(UNDERPSF,[2 2],<span class="string">'replicate'</span>,<span class="string">'both'</span>);
[J3 P3] = deconvblind(Blurred,INITPSF);
figure;imshow(J3);title(<span class="string">'Deblurring with INITPSF'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_05.png" alt=""> <h2>Step 4: Analyzing the Restored PSF<a name="7"></a></h2><p>All three restorations also produce a PSF. The following pictures show how the analysis of the reconstructed PSF might help in guessing the right size for the initial PSF. In the true PSF, a Gaussian filter, the maximum values are at the center (white) and diminish at the borders (black).</p><pre class="codeinput">figure;
subplot(221);imshow(PSF,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'True PSF'</span>);
subplot(222);imshow(P1,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed Undersized PSF'</span>);
subplot(223);imshow(P2,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed Oversized PSF'</span>);
subplot(224);imshow(P3,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed true PSF'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_06.png" alt=""> <p>The PSF reconstructed in the first restoration, <tt>P1</tt>, obviously does not fit into the constrained size. It has a strong signal variation at the borders. The corresponding image, <tt>J1</tt>, does not show any improved clarity vs. the blurred image, <tt>Blurred</tt>.</p><p>The PSF reconstructed in the second restoration, <tt>P2</tt>, becomes very smooth at the edges. This implies that the restoration can handle a PSF of a smaller size. The corresponding image, <tt>J2</tt>, shows some deblurring but it is strongly corrupted by the ringing.</p><p>Finally, the PSF reconstructed in the third restoration, <tt>P3</tt>, is somewhat intermediate between <tt>P1</tt> and <tt>P2</tt>. The array, <tt>P3</tt>, resembles the true PSF very well. The corresponding image, <tt>J3</tt>, shows significant improvement; however it is still corrupted by the ringing.</p><h2>Step 5: Improving the Restoration<a name="11"></a></h2><p>The ringing in the restored image, <tt>J3</tt>, occurs along the areas of sharp intensity contrast in the image and along the image borders. This example shows how to reduce the ringing effect by specifying a weighting function. The algorithm weights each pixel according to the <tt>WEIGHT</tt> array while restoring the image and the PSF. In our example, we start by finding the "sharp" pixels using the edge function. By trial and error, we determine that a desirable threshold level is 0.3.</p><pre class="codeinput">WEIGHT = edge(I,<span class="string">'sobel'</span>,.3);
</pre><p>To widen the area, we use <tt>imdilate</tt> and pass in a structuring element, <tt>se</tt>.</p><pre class="codeinput">se = strel(<span class="string">'disk'</span>,2);
WEIGHT = 1-double(imdilate(WEIGHT,se));
</pre><p>The pixels close to the borders are also assigned the value 0.</p><pre class="codeinput">WEIGHT([1:3 end-[0:2]],:) = 0;
WEIGHT(:,[1:3 end-[0:2]]) = 0;
figure;imshow(WEIGHT);title(<span class="string">'Weight array'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_07.png" alt=""> <p>The image is restored by calling deconvblind with the <tt>WEIGHT</tt> array and an increased number of iterations (30). Almost all the ringing is suppressed.</p><pre class="codeinput">[J P] = deconvblind(Blurred,INITPSF,30,[],WEIGHT);
figure;imshow(J);title(<span class="string">'Deblurred Image'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_08.png" alt=""> <h2>Step 6: Using Additional Constraints on the PSF Restoration<a name="15"></a></h2><p>The example shows how you can specify additional constraints on the PSF. The function, <tt>FUN</tt>, below returns a modified PSF array which deconvblind uses for the next iteration.</p><p>In this example, <tt>FUN</tt> modifies the PSF by cropping it by <tt>P1</tt> and <tt>P2</tt> number of pixels in each dimension, and then padding the array back to its original size with zeros. This operation does not change the values in the center of the PSF, but effectively reduces the PSF size by <tt>2*P1</tt> and <tt>2*P2</tt> pixels.</p><pre class="codeinput">P1 = 2;
P2 = 2;
FUN = @(PSF) padarray(PSF(P1+1:end-P1,P2+1:end-P2),[P1 P2]);
</pre><p>The anonymous function, <tt>FUN</tt>, is passed into <tt>deconvblind</tt> last.</p><p>In this example, the size of the initial PSF, <tt>OVERPSF</tt>, is 4 pixels larger than the true PSF. Setting P1=2 and P2=2 as parameters in <tt>FUN</tt> effectively makes the valuable space in <tt>OVERPSF</tt> the same size as the true PSF. Therefore, the outcome, <tt>JF</tt> and <tt>PF</tt>, is similar to the result of deconvolution with the right sized PSF and no <tt>FUN</tt> call, <tt>J</tt> and <tt>P</tt>, from step 4.</p><pre class="codeinput">[JF PF] = deconvblind(Blurred,OVERPSF,30,[],WEIGHT,FUN);
figure;imshow(JF);title(<span class="string">'Deblurred Image'</span>);
</pre><img vspace="5" hspace="5" src="ipexblind_09.png" alt=""> <p>If we had used the oversized initial PSF, <tt>OVERPSF</tt>, without the constraining function, <tt>FUN</tt>, the resulting image would be similar to the unsatisfactory result, <tt>J2</tt>, achieved in Step 3.</p><p>Note, that any unspecified parameters before <tt>FUN</tt> can be omitted, such as <tt>DAMPAR</tt> and <tt>READOUT</tt> in this example, without requiring a place holder, ([]).</p><p class="footer">Copyright 2004-2005 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Deblurring Images Using the Blind Deconvolution Algorithm 
% The Blind Deconvolution Algorithm can be used effectively when no
% information about the distortion (blurring and noise) is known. The
% algorithm restores the image and the point-spread function (PSF)
% simultaneously. The accelerated, damped Richardson-Lucy algorithm is used
% in each iteration. Additional optical system (e.g. camera)
% characteristics can be used as input parameters that could help to
% improve the quality of the image restoration. PSF constraints can be
% passed in through a user-specified function

% Copyright 2004-2005 The MathWorks, Inc.

%% Step 1: Read Image
% The example reads in an intensity image. The |deconvblind| function can
% handle arrays of any dimension.

I = imread('cameraman.tif');
figure;imshow(I);title('Original Image');
text(size(I,2),size(I,1)+15, ...
    'Image courtesy of Massachusetts Institute of Technology', ...
    'FontSize',7,'HorizontalAlignment','right');

%% Step 2: Simulate a Blur 
% Simulate a real-life image that could be blurred (e.g., due to camera
% motion or lack of focus). The example simulates the blur by convolving a
% Gaussian filter with the true image (using |imfilter|). The Gaussian filter
% then represents a point-spread function, |PSF|.

PSF = fspecial('gaussian',7,10);
Blurred = imfilter(I,PSF,'symmetric','conv');
figure;imshow(Blurred);title('Blurred Image');

%% Step 3: Restore the Blurred Image Using PSFs of Various Sizes 
% To illustrate the importance of knowing the size of the true PSF, this
% example performs three restorations. Each time the PSF reconstruction
% starts from a uniform arrayREPLACE_WITH_DASH_DASHan array of ones.

%%
% The first restoration, |J1| and |P1|, uses an undersized array, |UNDERPSF|, for
% an initial guess of the PSF. The size of the UNDERPSF array is 4 pixels
% shorter in each dimension than the true PSF. 

UNDERPSF = ones(size(PSF)-4);
[J1 P1] = deconvblind(Blurred,UNDERPSF);
figure;imshow(J1);title('Deblurring with Undersized PSF');

%%
% The second restoration, |J2| and |P2|, uses an array of ones, |OVERPSF|, for an
% initial PSF that is 4 pixels longer in each dimension than the true PSF.

OVERPSF = padarray(UNDERPSF,[4 4],'replicate','both');
[J2 P2] = deconvblind(Blurred,OVERPSF);
figure;imshow(J2);title('Deblurring with Oversized PSF');

%%
% The third restoration, |J3| and |P3|, uses an array of ones, |INITPSF|, for an
% initial PSF that is exactly of the same size as the true PSF.

INITPSF = padarray(UNDERPSF,[2 2],'replicate','both');
[J3 P3] = deconvblind(Blurred,INITPSF);
figure;imshow(J3);title('Deblurring with INITPSF');

%% Step 4: Analyzing the Restored PSF
% All three restorations also produce a PSF. The following pictures show
% how the analysis of the reconstructed PSF might help in guessing the
% right size for the initial PSF. In the true PSF, a Gaussian filter, the
% maximum values are at the center (white) and diminish at the borders (black).

figure;
subplot(221);imshow(PSF,[],'InitialMagnification','fit');
title('True PSF');
subplot(222);imshow(P1,[],'InitialMagnification','fit');
title('Reconstructed Undersized PSF');
subplot(223);imshow(P2,[],'InitialMagnification','fit');
title('Reconstructed Oversized PSF');
subplot(224);imshow(P3,[],'InitialMagnification','fit');
title('Reconstructed true PSF');

%% 
% The PSF reconstructed in the first restoration, |P1|, obviously does not
% fit into the constrained size. It has a strong signal variation at the
% borders. The corresponding image, |J1|, does not show any improved clarity
% vs. the blurred image, |Blurred|.

%%
% The PSF reconstructed in the second restoration, |P2|, becomes very smooth
% at the edges. This implies that the restoration can handle a PSF of a
% smaller size. The corresponding image, |J2|, shows some deblurring but it
% is strongly corrupted by the ringing.

%%
% Finally, the PSF reconstructed in the third restoration, |P3|, is somewhat
% intermediate between |P1| and |P2|. The array, |P3|, resembles the true PSF
% very well. The corresponding image, |J3|, shows significant improvement;
% however it is still corrupted by the ringing.

%% Step 5: Improving the Restoration
% The ringing in the restored image, |J3|, occurs along the areas of sharp
% intensity contrast in the image and along the image borders. This example
% shows how to reduce the ringing effect by specifying a weighting
% function. The algorithm weights each pixel according to the |WEIGHT| array
% while restoring the image and the PSF. In our example, we start by
% finding the "sharp" pixels using the edge function. By trial and error,
% we determine that a desirable threshold level is 0.3.

WEIGHT = edge(I,'sobel',.3);

%%
% To widen the area, we use |imdilate| and pass in a structuring element, |se|.

se = strel('disk',2);
WEIGHT = 1-double(imdilate(WEIGHT,se));

%%
% The pixels close to the borders are also assigned the value 0.

WEIGHT([1:3 end-[0:2]],:) = 0;
WEIGHT(:,[1:3 end-[0:2]]) = 0;
figure;imshow(WEIGHT);title('Weight array');

%%
% The image is restored by calling deconvblind with the |WEIGHT| array and an
% increased number of iterations (30). Almost all the ringing is suppressed.

[J P] = deconvblind(Blurred,INITPSF,30,[],WEIGHT);
figure;imshow(J);title('Deblurred Image');

%% Step 6: Using Additional Constraints on the PSF Restoration
% The example shows how you can specify additional constraints on the PSF.
% The function, |FUN|, below returns a modified PSF array which deconvblind
% uses for the next iteration. 
%
% In this example, |FUN| modifies the PSF by cropping it by |P1| and |P2| number
% of pixels in each dimension, and then padding the array back to its
% original size with zeros. This operation does not change the values in
% the center of the PSF, but effectively reduces the PSF size by |2*P1| and
% |2*P2| pixels. 

P1 = 2;
P2 = 2;
FUN = @(PSF) padarray(PSF(P1+1:end-P1,P2+1:end-P2),[P1 P2]);

%%
% The anonymous function, |FUN|, is passed into |deconvblind| last.

%%
% In this example, the size of the initial PSF, |OVERPSF|, is 4 pixels larger
% than the true PSF. Setting P1=2 and P2=2 as parameters in |FUN|
% effectively makes the valuable space in |OVERPSF| the same size as the true
% PSF. Therefore, the outcome, |JF| and |PF|, is similar to the result of
% deconvolution with the right sized PSF and no |FUN| call, |J| and |P|, from
% step 4.

[JF PF] = deconvblind(Blurred,OVERPSF,30,[],WEIGHT,FUN);
figure;imshow(JF);title('Deblurred Image');

%%
% If we had used the oversized initial PSF, |OVERPSF|, without the
% constraining function, |FUN|, the resulting image would be similar to the
% unsatisfactory result, |J2|, achieved in Step 3.
%
% Note, that any unspecified parameters before |FUN| can be omitted, such as
% |DAMPAR| and |READOUT| in this example, without requiring a place holder,
% ([]).


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>