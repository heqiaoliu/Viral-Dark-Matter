
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>3 次元 MRI データ セットからのスライスの調査</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexmri.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexmri">エディターで ipexmri.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexmri">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>3 次元 MRI データ セットからのスライスの調査</h1><!--introduction--><p>関数 <tt>imtransform</tt> および <tt>tformarray</tt> を使用して、3 次元 MRI データ セットを内挿して再スライスします。これにより、大量のデータを表示する便利な方法が提供されます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:水平 MRI の読み込みと表示</a></li><li><a href="#3">手順 2:IMTRANSFORM を使用した水平スライスからの矢状スライスの抽出</a></li><li><a href="#8">手順 3:TFORMARRAY を使用した水平スライスからの矢状スライスの抽出</a></li><li><a href="#14">手順 4:矢状スライスの作成と表示</a></li><li><a href="#18">手順 5:冠状スライスの作成と表示</a></li></ul></div><h2>手順 1:水平 MRI の読み込みと表示<a name="1"></a></h2><p>このデモでは、MATLAB&reg; に付属しており、<tt>montage</tt> および <tt>immovie</tt> のヘルプの例で使用される MRI データ セットを使用します。<tt>mri.mat</tt> の読み込みにより、2 つの変数がワークスペースに追加されます。その変数とは、<tt>D</tt> (128&times;128&times;1&times;27、クラス uint8) と、グレースケール カラーマップ <tt>map</tt> (89&times;3、クラス double) です。</p><p><tt>D</tt> は、人間の頭蓋の MRI データ スキャンによる 27 の 128&times;128 水平スライスで構成されます。<tt>D</tt> の値の範囲は 0 から 88 までなので、有効な視覚範囲で図を生成するには、カラーマップが必要になります。<tt>D</tt> の次元により、<tt>montage</tt> に対応できます。最初の 2 つの次元は空間です。3 番目の次元は色の次元であり、色のマップにインデックスを付けるので、サイズが 1 になります (<tt>size(D,3)</tt> は RGB イメージ列に対して 3 になります)。4 番目の次元は一連の画像の時間経過を示すものです。ただし、この場合は空間でもあります。<tt>D</tt> には 3 つの空間次元があるので、<tt>imtransform</tt> または <tt>tformarray</tt> を使用して水平スライスを、矢状スライス (頭部の外側から表示) または冠状 (前頭骨) スライス (頭部の前または後ろからの表示) に変換できます。</p><p><tt>D</tt> の空間次元は以下のように順番付けられます。</p><div><ul><li>次元 1:頭部の前から後ろ (頭方/前方から尾側/後方)</li><li>次元 2:頭部の左側から右側</li><li>次元 4:頭部の底部から上部 (下側から上側)。</li></ul></div><p>重要な要素は、サンプリング間隔が 3 つの次元に沿って同じではないことです。垂直次元 (4) に沿ったサンプルは、水平次元よりも 2.5 倍広い間隔に配置されます。</p><p>MRI データ セットを読み込み、モンタージュとして 27 の水平スライスを表示します。</p><pre class="codeinput">load <span class="string">mri</span>;
montage(D,map)
title(<span class="string">'Horizontal Slices'</span>);
</pre><img vspace="5" hspace="5" src="../ipexmri_01.png" alt=""> <h2>手順 2:IMTRANSFORM を使用した水平スライスからの矢状スライスの抽出<a name="3"></a></h2><p>さまざまなサンプリング間隔と <tt>D</tt> の次元の空間的定位を明らかにするために、<tt>D</tt> のサブセットを取って変換することで、MRI データからの中間の矢状スライスを作成できます。</p><p>以下のステートメントは、中間の矢状スライスに必要なすべてのデータを抽出します。</p><pre class="codeinput">M1 = D(:,64,:,:); size(M1)
</pre><pre class="codeoutput">
ans =

   128     1     1    27

</pre><p>ただし、<tt>M1</tt> は 128&times;1&times;1&times;27 なので、イメージとして表示できません。<tt>reshape</tt> (または <tt>squeeze</tt>) は <tt>M1</tt> を、<tt>imshow</tt> で表示可能な 128&times;27 のイメージに変換できます。.</p><pre class="codeinput">M2 = reshape(M1,[128 27]); size(M2)
figure, imshow(M2,map);
title(<span class="string">'Sagittal - Raw Data'</span>);
</pre><pre class="codeoutput">
ans =

   128    27

</pre><img vspace="5" hspace="5" src="../ipexmri_02.png" alt=""> <p><tt>M2</tt> の次元は、次のような順序に並べられます。</p><div><ul><li>次元 1:頭部の前から後ろ (頭方から尾側)</li><li>次元 2:頭部の底部から上部 (下側から上側)。</li></ul></div><p><tt>M2</tt> を変換して方向を変更し、垂直 (下側-上側) 次元に沿ってサンプリングをファクター 2.5 ずつ増加させることで、より満足のいく表示を得ることができます。これにより、サンプリング間隔は 3 つすべての空間次元で等しくなります。これは、転置から始まる手順で行うことができますが、以下に示すアフィン変換を使用すると、シングルステップ変換が可能になり、メモリを無駄なく使用できるようになります。</p><pre class="codeinput">T0 = maketform(<span class="string">'affine'</span>,[0 -2.5; 1 0; 0 0]);
</pre><p>maketform <tt>0 -2.5;1 0]</tt> に渡される行列の上部 2&times;2 ブロックは、回転およびスケーリングを結合したものです。変換後、以下のようになります。</p><div><ul><li>次元 1:頭部の上部から底部 (下側から上側)</li><li>次元 2:頭部の前から後ろ (頭方から尾側)</li></ul></div><p>次の呼び出し</p><p>imtransform(M2,T0,'cubic')</p><p>は、上から下の方向に沿って内挿すると同時に、<tt>T</tt> を <tt>M2</tt> に適用し、最適な解像度を提供するのに十分です。ただし、(出力) 次元 2 に沿った再サンプリングは発生しないので、前後方向でのキュービック内挿の必要はありません。そのため、より効率性が高く結果が同じであるこの次元で最近傍再サンプリングを指定します。</p><pre class="codeinput">R2 = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>},<span class="string">'fill'</span>);
M3 = imtransform(M2,T0,R2);
figure, imshow(M3,map);
title(<span class="string">'Sagittal - IMTRANSFORM'</span>)
</pre><img vspace="5" hspace="5" src="../ipexmri_03.png" alt=""> <h2>手順 3:TFORMARRAY を使用した水平スライスからの矢状スライスの抽出<a name="8"></a></h2><p>この手順では、手順 2 と同じ結果が得られますが、<tt>tformarray</tt> を使用して、3 つの空間次元から 2 つの空間次元まで 1 つの操作で移動します。手順 2 は 3 つの空間次元を持つ配列から始まり、2 つの空間次元を持つ配列で終わりますが、中間の 2 次元イメージ (<tt>M1</tt> と <tt>M2</tt>) は、<tt>M3</tt> を作成する <tt>imtransform</tt> 呼び出しのための準備をします。<tt>imtransform</tt> の代わりに <tt>tformarray</tt> を使用する場合、これらの中間イメージは不要です。<tt>imtransform</tt> は 2 次元から 2 次元への変換に便利ですが、<tt>tformarray</tt> は N 次元から M 次元への変換をサポートしています (ここで、M は N と同じである必要はありません)。</p><p>その <tt>TDIMS_A</tt> 引数により、<tt>tformarray</tt> で入力配列の置換を定義できるようになります。以下の次元でイメージを作成し、</p><div><ul><li>次元 1:下側から上側 (元の次元 4、反転)</li><li>次元 2:頭方から尾側 (元の次元 1)</li></ul></div><p>元の次元 2 を介して 1 つの矢状平面のみを抽出するので、<tt>tdims_a</tt> = [4 1 2] を指定します。2 次元アフィン変換 <tt>T1</tt> で始まる合成により <tt>tform</tt> を作成します。このアフィン変換は (新しい) 次元 1 を 2.5 のファクターでスケーリングし 68.5 のシフトを足して、配列の座標を正のままにします。合成の 2 番目の部分はカスタム変換 <tt>T2</tt> です。これは、非常に単純な <tt>INVERSE_FCN</tt> を使用して 64 番目の矢状平面を抽出します。</p><pre class="codeinput">T1 = maketform(<span class="string">'affine'</span>,[-2.5 0; 0 1; 68.5 0]);
inverseFcn = @(X,t) [X repmat(t.tdata,[size(X,1) 1])];
T2 = maketform(<span class="string">'custom'</span>,3,2,[],inverseFcn,64);
Tc = maketform(<span class="string">'composite'</span>,T1,T2);
</pre><p><tt>T2</tt> および <tt>Tc</tt> は、3 次元入力を 2 次元入力に移行することに注意してください。</p><p>前と同じ再サンプリングの方法を使用しますが、3 番目の次元を含みます。</p><pre class="codeinput">R3 = makeresampler({<span class="string">'cubic'</span>,<span class="string">'nearest'</span>,<span class="string">'nearest'</span>},<span class="string">'fill'</span>);
</pre><p><tt>tformarray</tt> は、1 つのステップで <tt>D</tt> の 3 つの空間次元を 2 次元の出力に変換します。この出力イメージは 66&times;128 であり、垂直方向 (下部-上部) に 66 に拡張された元の 27 の平面を持っています。</p><pre class="codeinput">M4 = tformarray(D,Tc,R3,[4 1 2],[1 2],[66 128],[],0);
</pre><p>この結果は、<tt>imtransform</tt> の前の出力と同じになります。</p><pre class="codeinput">figure, imshow(M4,map);
title(<span class="string">'Sagittal - TFORMARRAY'</span>);
</pre><img vspace="5" hspace="5" src="../ipexmri_04.png" alt=""> <h2>手順 4:矢状スライスの作成と表示<a name="14"></a></h2><p>4 次元配列 (3 番目の次元は色の次元です) を作成します。これを使用して、左から右に移動し、その中の 30 平面を開始し、その他すべての平面をスキップする、合計 35 フレームを持つイメージ列を生成できます。変換された配列には以下のものが含まれます。</p><div><ul><li>次元 1:上部から底部 (下側から上側)</li><li>次元 2:前から後ろ (頭方から尾側)</li><li>次元 4:左から右</li></ul></div><p>前の手順と同様に、<tt>TDIMS_A = [4 1 2]</tt> を使用して入力配列の順序を変えます。再度、垂直次元の反転と、再スケーリング/再サンプリングが行われます。アフィン変換は、30、32、... 98 を 1、2、...、35 にマッピングするよう選択された 0.5 の (3,3) 要素を持つの 3 番目の次元と -14 の (4,3) 要素を加えることを除いて、上記の T1 と同じです。これは、35 のフレームを中間の矢状スライスの真ん中に置きます。</p><pre class="codeinput">T3 = maketform(<span class="string">'affine'</span>,[-2.5 0 0; 0 1 0; 0 0 0.5; 68.5 0 -14]);
</pre><p><tt>tformarray</tt> の呼び出しでは、<tt>TSIZE_B = [66 128 35]</tt> は 4 番目の左から右への次元 (3 番目の変換次元) に 35 のフレームを含めます。再サンプラーは変化しません。</p><pre class="codeinput">S = tformarray(D,T3,R3,[4 1 2],[1 2 4],[66 128 35],[],0);
</pre><p>矢状スライスをモンタージュとして表示します (モンタージュの要素を区切るため、配列を若干付加します)。</p><pre class="codeinput">S2 = padarray(S,[6 0 0 0],0,<span class="string">'both'</span>);
figure, montage(S2,map)
title(<span class="string">'Sagittal Slices'</span>);
</pre><img vspace="5" hspace="5" src="../ipexmri_05.png" alt=""> <h2>手順 5:冠状スライスの作成と表示<a name="18"></a></h2><p>冠状スライスの作成は、矢状スライスの作成とほぼ同じです。<tt>TDIMS_A</tt> を <tt>[4 1 2]</tt> から <tt>[4 2 1]</tt> に変更します。45 の一連のフレームを作成します。その中の 8 平面を開始して後ろから前に移動し、他のすべてのフレームをスキップします。出力配列の次元は以下のような順序に並べられます。</p><div><ul><li>次元 1:上部から底部 (下側から上側)</li><li>次元 2:左から右</li><li>次元 4:後ろから前 (尾側から頭方)</li></ul></div><pre class="codeinput">T4 = maketform(<span class="string">'affine'</span>,[-2.5 0 0; 0 1 0; 0 0 -0.5; 68.5 0 61]);
</pre><p><tt>tformarray</tt> の呼び出しでは、<tt>TSIZE_B</tt> = [66 128 48] はそれぞれ、垂直、端から端まで、および前から後ろの次元を指定します。再サンプラーは変化しません。</p><pre class="codeinput">C = tformarray(D,T4,R3,[4 2 1],[1 2 4],[66 128 45],[],0);
</pre><p>手順 3、4、および 5 のすべての配列の順列と反転は、<tt>tformarray</tt> 操作の一部として処理されたことに注意してください。</p><p>冠状スライスをモンタージュとして表示します (モンタージュの要素を区切るため、配列を若干付加します)。</p><pre class="codeinput">C2 = padarray(C,[6 0 0 0],0,<span class="string">'both'</span>);
figure, montage(C2,map)
title(<span class="string">'Coronal Slices'</span>);
</pre><img vspace="5" hspace="5" src="../ipexmri_06.png" alt=""> <p class="footer">Copyright 1993-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Exploring Slices from a 3-Dimensional MRI Data Set % Copyright 1993-2009 The MathWorks, Inc. % The |imtransform| and |tformarray| functions can be used to interpolate and % reslice a three-dimensional MRI data set, providing a convenient way to % view a volume of data.  %% Step 1: Load and View Horizontal MRI % This demonstration uses the MRI data set that comes with MATLAB(R) and that is % used in the help examples for both |montage| and |immovie|. Loading % |mri.mat| adds two variables to the workspace: |D| (128-by-128-by-1-by-27, % class uint8) and a grayscale colormap, |map| (89-by-3, class double). % % |D| comprises 27 128-by-128 horizontal slices from an MRI data scan of a human % cranium. Values in |D| range from 0 through 88, so the colormap is needed to % generate a figure with a useful visual range. The dimensionality of |D| makes % it compatible with |montage|. The first two dimensions are spatial. The third % dimension is the color dimension, with size 1 because it indexes into the % color map. (|size(D,3)| would be 3 for an RGB image sequence.) The fourth % dimension is temporal (as with any image sequence), but in this particular % case it is also spatial. So there are three spatial dimensions in |D| and we % can use |imtransform| or |tformarray| to convert the horizontal slices to % sagittal slices (showing the view from the side of the head) or coronal % (frontal) slices (showing the view from the front or back of the head). % % The spatial dimensions of |D| are ordered as follows: %  % * Dimension 1: Front to back of head (rostral/anterior to caudal/posterior)  % * Dimension 2: Left to right of head  % * Dimension 4: Bottom to top of head (inferior to superior). % % An important factor is that the sampling intervals are not the same along % the three dimensions: samples along the vertical dimension (4) are spaced % 2.5 times more widely than along the horizontal dimensions.  %%  % Load the MRI data set and view the 27 horizontal slices as a montage.  load mri; montage(D,map) title('Horizontal Slices');  %% Step 2: Extract Sagittal Slice from Horizontal Slices Using IMTRANSFORM % We can construct a mid-sagittal slice from the MRI data by taking a subset % of |D| and transforming it to account for the different sampling intervals % and the spatial orientation of the dimensions of |D|. % % The following statement extracts all the data needed for a midsagittal % slice.  M1 = D(:,64,:,:); size(M1)  %% % However we cannot view |M1| as an image because it is 128-by-1-by-1-by-27. % |reshape| (or |squeeze|) can convert |M1| into a 128-by-27 image that % is viewable with |imshow|.  M2 = reshape(M1,[128 27]); size(M2) figure, imshow(M2,map); title('Sagittal - Raw Data');  %% % The dimensions in |M2| are ordered as follows: % % * Dimension 1: Front to back of head (rostral to caudal)  % * Dimension 2: Bottom to top of head (inferior to superior).  % % We can obtain a much more satisfying view by transforming |M2| to change % its orientation and increase the sampling along the vertical % (inferior-superior) dimension by a factor of 2.5 REPLACE_WITH_DASH_DASH making the sampling % interval equal in all three spatial dimensions. We could do this in steps % starting with a transpose, but the following affine transformation % enables a single-step transformation and more economical use of memory.  T0 = maketform('affine',[0 -2.5; 1 0; 0 0]);  %% % The upper 2-by-2 block of the matrix passed to maketform, |0 -2.5;1 0]|, % combines the rotation and scaling. After transformation we have: % % * Dimension 1: Top to bottom of head (superior to inferior).  % * Dimension 2: Front to back of head (rostral to caudal)   %% % The call % % imtransform(M2,T0,'cubic') %  % would suffice to apply |T| to |M2| and provide good resolution while % interpolating along the top to bottom direction. However, there is no % need for cubic interpolation in the front to back direction, since no % resampling will occur along (output) dimension 2. Therefore we specify % nearest-neighbor resampling in this dimension, with greater efficiency % and identical results.  R2 = makeresampler({'cubic','nearest'},'fill'); M3 = imtransform(M2,T0,R2); figure, imshow(M3,map); title('Sagittal - IMTRANSFORM')  %% Step 3: Extract Sagittal Slice from the Horizontal Slices Using TFORMARRAY % In this step we obtain the same result as step 2, but use |tformarray| to go % from three spatial dimensions to two in a single operation. Step 2 does % start with an array having three spatial dimensions and end with an array % having two spatial dimensions, but intermediate two-dimensional images (|M1| % and |M2|) pave the way for the call to |imtransform| that creates % |M3|. These intermediate images are not necessary if we use |tformarray| % instead of |imtransform|. |imtransform| is very convenient for 2-D to 2-D % transformations, but |tformarray| supports N-D to M-D transformations, where % M need not equal N.  %% % Through its |TDIMS_A| argument, |tformarray| allows us to define a % permutation for the input array. Since we want to create an image with: % % * Dimension 1: Superior to inferior (original dimension 4, reversed)  % * Dimension 2: Caudal to rostral (original dimension 1)  % % and extract just a single sagittal plane via the original dimension 2, we % specify |tdims_a| = [4 1 2]. We create a |tform| via composition starting % with a 2-D affine transformation |T1| that scales the (new) dimension 1 by a % factor of -2.5 and adds a shift of 68.5 to keep the array coordinates % positive. The second part of the composite is a custom transformation |T2| % that extracts the 64th sagittal plane using a very simple |INVERSE_FCN|.  T1 = maketform('affine',[-2.5 0; 0 1; 68.5 0]); inverseFcn = @(X,t) [X repmat(t.tdata,[size(X,1) 1])]; T2 = maketform('custom',3,2,[],inverseFcn,64); Tc = maketform('composite',T1,T2);  %% % Note that |T2| and |Tc| take a 3-D input to a 2-D input.  %% % We use the same approach to resampling as before, but include a third dimension.  R3 = makeresampler({'cubic','nearest','nearest'},'fill');  %% % |tformarray| transforms the three spatial dimensions of |D| to a 2-D output % in a single step. Our output image is 66-by-128, with the original 27 planes % expanding to 66 in the vertical (inferior-superior) direction.  M4 = tformarray(D,Tc,R3,[4 1 2],[1 2],[66 128],[],0);  %% % The result is identical to the previous output of |imtransform|.  figure, imshow(M4,map); title('Sagittal - TFORMARRAY');  %% Step 4: Create and Display Sagittal Slices % We create a 4-D array (the third dimension is the color dimension) that can be % used to generate an image sequence that goes from left to right, starts 30 % planes in, skips every other plane, and has 35 frames in total. The % transformed array has: % % * Dimension 1: Top to bottom (superior to inferior)  % * Dimension 2: Front to back (rostral to caudal)  % * Dimension 4: Left to right.   %% % As in the previous step, we permute the input array using  % |TDIMS_A = [4 1 2]|, again flipping and rescaling/resampling the vertical % dimension. Our affine transformation is the same as the T1 above, except % that we add a third dimension with a (3,3) element of 0.5 and (4,3) element % of -14 chosen to map 30, 32, ... 98 to 1, 2, ..., 35. This centers our 35 % frames on the mid-sagittal slice.  T3 = maketform('affine',[-2.5 0 0; 0 1 0; 0 0 0.5; 68.5 0 -14]);  %% % In our call to |tformarray|, |TSIZE_B = [66 128 35]| now includes the 35 % frames in the 4th, left-to-right dimension (which is the third transform % dimension). The resampler remains the same.  S = tformarray(D,T3,R3,[4 1 2],[1 2 4],[66 128 35],[],0);  %% % View the sagittal slices as a montage (padding the array slightly to separate  % the elements of the montage).  S2 = padarray(S,[6 0 0 0],0,'both'); figure, montage(S2,map) title('Sagittal Slices');  %% Step 5: Create and Display Coronal Slices % Constructing coronal slices is almost the same as constructing sagittal % slices. We change |TDIMS_A| from |[4 1 2]| to |[4 2 1]|. We create a series % of 45 frames, starting 8 planes in and moving from back to front, skipping % every other frame. The dimensions of the output array are ordered as % follows: % % * Dimension 1: Top to bottom (superior to inferior)  % * Dimension 2: Left to right  % * Dimension 4: Back to front (caudal to rostral).   T4 = maketform('affine',[-2.5 0 0; 0 1 0; 0 0 -0.5; 68.5 0 61]);  %% % In our call to |tformarray|, |TSIZE_B| = [66 128 48] specifies the vertical, % side-to-side, and front-to-back dimensions, respectively. The resampler % remains the same.  C = tformarray(D,T4,R3,[4 2 1],[1 2 4],[66 128 45],[],0);  %% % Note that all array permutations and flips in steps 3, 4, and 5 were handled % as part of the |tformarray| operation.  %% % View the coronal slices as a montage (padding the array slightly to separate  % the elements of the montage).  C2 = padarray(C,[6 0 0 0],0,'both'); figure, montage(C2,map) title('Coronal Slices');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>