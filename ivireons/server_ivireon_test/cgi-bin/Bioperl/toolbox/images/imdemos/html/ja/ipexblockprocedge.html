
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>大きなイメージのブロック処理</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexblockprocedge.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexblockprocedge">エディターで ipexblockprocedge.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexblockprocedge">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>大きなイメージのブロック処理</h1><!--introduction--><p>大きなイメージを処理する場合、通常のイメージ処理手法が正常に機能しない場合があります。イメージがメモリに読み込むには大きすぎるか、メモリに読み込めるが大きすぎて処理できないことが原因と考えられます。</p><p>これらの問題を回避するには、イメージを複数の領域に分割し、各領域を別々に読み取り、処理し、最後に結果をディスクに書き込み、全体のイメージを再構築します。 関数 <tt>blockproc</tt> はこの処理に役立ちます。関数 <tt>blockproc</tt> を使用して、イメージ、ブロック サイズ、および関数ハンドルを指定します。<tt>blockproc</tt> は、入力イメージを指定されたサイズのブロックに分け、関数ハンドルを使用してブロックを 1 つずつ処理し、結果を集めて出力イメージを作成します。<tt>blockproc</tt> は出力をメモリまたはディスク上の新しいファイルに返します。</p><p>このデモでは、<tt>blockproc</tt> を簡単な画像処理作業 (TIFF イメージでエッジ検出を行う) に使用する方法について説明します。構文情報の詳細については、<a href="matlab:doc('blockproc')"><tt>blockproc</tt></a> のドキュメンテーションを参照してください。</p><!--/introduction--><p>最初に、ブロック処理を使用しないでエッジ検出を実行した場合の結果を検討します。この例では小さなイメージ cameraman.tif を使用して概念を説明しますが、大きなイメージではしばしばブロック処理が役立ちます。</p><pre class="codeinput">file_name = <span class="string">'cameraman.tif'</span>;
I = imread(file_name);
normal_edges = edge(I,<span class="string">'canny'</span>);
imshow(I);
title(<span class="string">'Original Image'</span>);
figure
imshow(normal_edges);
title(<span class="string">'Conventional Edge Detection'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblockprocedge_01.png" alt=""> <img vspace="5" hspace="5" src="../ipexblockprocedge_02.png" alt=""> <p>次にブロック処理を使用して同じ作業を行います。関数 <tt>blockproc</tt> には TIFF イメージのサポートが組み込まれているため、<tt>imread</tt> を使用してファイルをすべてメモリに読み込む必要はありません。代わりに、文字列のファイル名を入力に使用して関数を呼び出します。<tt>blockproc</tt> はブロックを 1 個ずつ読み取り、このワークフローを大きなイメージで最適になるようにします。</p><p>大きなイメージを処理する場合、'Destination' パラメーターを使用して、<tt>blockproc</tt> が出力イメージを書き込むファイルを指定することがよくあります。ただし、この例では結果をメモリ内の変数に返します。</p><p>この例では [50 50] のブロック サイズを使用します。通常、大きなブロック サイズを選択すると <tt>blockproc</tt> のパフォーマンスが向上します。これは、ディスクへのアクセスが大幅なパフォーマンス コストにつながるファイルツーファイルのワークフローに特に当てはまります。適切なブロック サイズは利用可能なマシン リソースによって異なりますが、次元あたり数千ピクセルの範囲にする必要があります。</p><pre class="codeinput"><span class="comment">% You can use an anonymous function to define the function handle.The</span>
<span class="comment">% function is passed a structure as input, a &quot;block struct&quot;, with several</span>
<span class="comment">% fields containing the block data as well as other relevant information.</span>
<span class="comment">% The function should return the processed block data.</span>
edgeFun = @(block_struct) edge(block_struct.data,<span class="string">'canny'</span>);

block_size = [50 50];
block_edges = blockproc(file_name,block_size,edgeFun);
figure
imshow(block_edges);
title(<span class="string">'Block Processing - Simplest Syntax'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblockprocedge_03.png" alt=""> <p>ブロック処理には重大なアーチファクトがあります。ピクセルがエッジ ピクセルかどうかを判定するには、隣接するピクセルからの情報が必要です。これは、各ブロックは周囲のピクセルと完全に切り離して処理することはできないことを意味します。この問題を修復するには、<tt>blockproc</tt> のパラメーター 'BorderSize' を使用して、各ブロックの周りの横および縦方向の境界を指定します。必要な 'BorderSize' は実行中のタスクに応じて異なります。</p><pre class="codeinput">border_size = [10 10];
block_edges = blockproc(file_name,block_size,edgeFun,<span class="string">'BorderSize'</span>,border_size);
figure
imshow(block_edges);
title(<span class="string">'Block Processing - Block Borders'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblockprocedge_04.png" alt=""> <p>ブロックは、現在、両面に 10 ピクセルのイメージ データを追加して処理されています。これは良さそうに見えますが、結果は元のメモリ内結果とは大幅に異なります。この理由は、Canny エッジ検出法では完全なイメージ ヒストグラムに基づいて計算されたしきい値を使用しているからです。関数 <tt>blockproc</tt> は各ブロックの関数 <tt>edge</tt> を呼び出すため、Canny アルゴリズムは不完全なヒストグラムで作業することになり、イメージ全体で異なるしきい値が使用されます。</p><p>イメージをブロック処理するときには、このようなタイプのアルゴリズム制約を理解することが重要です。一部の関数は、すべての構文を直接ブロック処理に変換するわけではありません。この場合、関数 <tt>edge</tt> を使用して、固定しきい値を計算する代わりに入力引数として渡すことができます。関数ハンドルを修正して <tt>edge</tt> の 3 引数構文を使用すると、関数のいずれかの &quot;グローバルな&quot; 制約が削除されます。試行錯誤により、しきい値が 0.09 のときに良い結果になることがわかっています。</p><pre class="codeinput">thresh = 0.09;
edgeFun = @(block_struct) edge(block_struct.data,<span class="string">'canny'</span>,thresh);
block_edges = blockproc(file_name,block_size,edgeFun,<span class="string">'BorderSize'</span>,border_size);
figure
imshow(block_edges);
title(<span class="string">'Block Processing - Borders &amp; Fixed Threshold'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblockprocedge_05.png" alt=""> <p>結果は元のメモリ内の結果とほぼ一致しています。境界沿いに追加のアーチファクトが見られます。これらのアーチファクトは、Canny エッジ検出法が使用する別の付加方法が原因です。現在、<tt>blockproc</tt> はイメージ境界でゼロ付加のみをサポートしています。</p><p class="footer">Copyright 2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Block Processing Large Images % When working with large images, normal image processing techniques can % sometimes break down.  The images can either be too large to load into % memory, or else they can be loaded into memory but then be too large to % process. % % To avoid these problems, you can process large images incrementally: % reading, processing, and finally writing the results back to disk, one % region at a time.  The |blockproc| function helps you with this process. % Using |blockproc|, specify an image, a block size, and a function handle. % |blockproc| then divides the input image into blocks of the specified % size, processes them using the function handle one block at a time, and % then assembles the results into an output image.  |blockproc| returns the % output to memory or to a new file on disk. % % This demo illustrates how to use |blockproc| for a simple image % processing task: performing edge detection on a TIFF image.  See the % documentation for <matlab:doc('blockproc') |blockproc|> for detailed % syntax information.  % Copyright 2009 The MathWorks, Inc.   %% % First, consider the results of performing edge detection without block % processing.  This example uses a small image, cameraman.tif, to % illustrate the concepts, but block processing is often more useful for % large images.  file_name = 'cameraman.tif'; I = imread(file_name); normal_edges = edge(I,'canny'); imshow(I); title('Original Image'); figure imshow(normal_edges); title('Conventional Edge Detection');  %% % Now try the same task using block processing.  The |blockproc| function % has built-in support for TIFF images, so you do not have to read the file % completely into memory using |imread|.  Instead, call the function using % the string filename as input.  |blockproc| reads in one block at a time, % making this workflow ideal for very large images. % % When working with large images you will often use the 'Destination' % parameter to specify a file into which |blockproc| will write the output % image.  However, in this example you will return the results to a % variable, in memory. % % This example uses a block size of [50 50].  In general, choosing larger % block sizes yields better performance for |blockproc|.  This is % particularly true for file-to-file workflows where accessing the disk % will incur a significant performance cost.  Appropriate block sizes vary  % based on the machine resources available, but should likely be in the % range of thousands of pixels per dimension.  % You can use an anonymous function to define the function handle. The % function is passed a structure as input, a "block struct", with several % fields containing the block data as well as other relevant information. % The function should return the processed block data. edgeFun = @(block_struct) edge(block_struct.data,'canny');  block_size = [50 50]; block_edges = blockproc(file_name,block_size,edgeFun); figure imshow(block_edges); title('Block Processing - Simplest Syntax');  %% % Notice the significant artifacts from the block processing.  Determining % whether a pixel is an edge pixel or not requires information from the % neighboring pixels.  This means that each block cannot be processed % completely separately from its surrounding pixels. To remedy this, use the % |blockproc| parameter 'BorderSize' to specify vertical and horizontal % borders around each block.  The necessary 'BorderSize' varies depending % on the task being performed.  border_size = [10 10]; block_edges = blockproc(file_name,block_size,edgeFun,'BorderSize',border_size); figure imshow(block_edges); title('Block Processing - Block Borders');  %% % The blocks are now being processed with an additional 10 pixels of image % data on each side.  This looks better, but the result is still % significantly different from the original in-memory result.  The reason % for this is that the Canny edge detector uses a threshold that is % computed based on the complete image histogram.  Since the |blockproc| % function calls the |edge| function for each block, the Canny algorithm is % working with incomplete histograms and therefore using varying thresholds % across the image. % % When block processing images, it is important to understand these types % of algorithm constraints.  Some functions will not directly translate to % block processing for all syntaxes.  In this case, the |edge| function % allows you to pass in a fixed threshold as an input argument instead of % computing it.  Modify your function handle to use the three-argument % syntax of |edge|, and thus remove one of the "global" constraints of the % function.  Some trial and error finds that a threshold of 0.09 gives good % results.  thresh = 0.09; edgeFun = @(block_struct) edge(block_struct.data,'canny',thresh); block_edges = blockproc(file_name,block_size,edgeFun,'BorderSize',border_size); figure imshow(block_edges); title('Block Processing - Borders & Fixed Threshold');  %% % The result now closely matches the original in-memory result.  You can % see some additional artifacts along the boundaries.  These are due to the % different methods of padding used by the Canny edge detector.  Currently, % |blockproc| only supports zero-padding along the image boundaries.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>