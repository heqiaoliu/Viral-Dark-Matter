
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>イメージの区分化を使用したセルの検出</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexcell.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexcell">エディターで ipexcell.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexcell">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>イメージの区分化を使用したセルの検出</h1><!--introduction--><p>オブジェクトは、背景と十分なコントラストがある場合、イメージ内で簡単に検出されます。エッジ検出と基本的な形態学的ツールを使用して、前立腺癌細胞を検出します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: セル全体の検出</a></li><li><a href="#3">手順 3: イメージの膨張</a></li><li><a href="#5">手順 4: 内部のギャップを埋める</a></li><li><a href="#6">手順 5: 境界につながるオブジェクトの削除</a></li><li><a href="#7">手順 6: オブジェクトの平滑化</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p><tt>cell.tif</tt> イメージを読み込みます。これは前立腺癌細胞のイメージです。 </p><pre class="codeinput">I = imread(<span class="string">'cell.tif'</span>);
figure, imshow(I), title(<span class="string">'original image'</span>);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of Alan Partin'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
text(size(I,2),size(I,1)+25, <span class="keyword">...</span><span class="comment">.</span>
    <span class="string">'Johns Hopkins University'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_01.png" alt=""> <h2>手順 2: セル全体の検出<a name="2"></a></h2><p>このイメージには 2 つの細胞がありますが、全体が見えるのは 1 つの細胞だけです。この細胞を検出します。オブジェクトの検出は区分化とも言い換えられます。区分化するオブジェクトは、コントラストが背景のイメージと大きく異なります。コントラストの変化は、画像勾配を計算する演算子によって検出できます。画像勾配を計算し、しきい値を適用して、区分化された細胞を含んでいるバイナリ マスクを作成できます。最初に、<tt>edge</tt> と Sobel 演算子を使用してしきい値を計算します。次にしきい値を調整し再度 <tt>edge</tt> を使用して、区分化された細胞を含んでいるバイナリ マスクを作成します。</p><pre class="codeinput">[junk threshold] = edge(I, <span class="string">'sobel'</span>);
fudgeFactor = .5;
BWs = edge(I,<span class="string">'sobel'</span>, threshold * fudgeFactor);
figure, imshow(BWs), title(<span class="string">'binary gradient mask'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_02.png" alt=""> <h2>手順 3: イメージの膨張<a name="3"></a></h2><p>バイナリの勾配マスクでは、イメージに高いコントラストの線が示されます。これらの線は、対象オブジェクトの輪郭を正確には表しません。元のイメージと比べて、勾配マスクのオブジェクトの周囲の線にはギャップがあります。これらの線のギャップは、線形構造化要素 （関数 <tt>strel</tt> で作成できる） を使用して Sobel イメージを膨張させると見えなくなります。</p><pre class="codeinput">se90 = strel(<span class="string">'line'</span>, 3, 90);
se0 = strel(<span class="string">'line'</span>, 3, 0);
</pre><p>バイナリの勾配マスクは、縦方向の構造化要素を使用し、次に横方向の構造化要素を使用して膨張します。関数 <tt>imdilate</tt> はイメージを膨張させます。</p><pre class="codeinput">BWsdil = imdilate(BWs, [se90 se0]);
figure, imshow(BWsdil), title(<span class="string">'dilated gradient mask'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_03.png" alt=""> <h2>手順 4: 内部のギャップを埋める<a name="5"></a></h2><p>膨張した勾配マスクでは細胞の輪郭がよく見えますが、細胞の内部にはまだホールがあります。これらのホールを塗り潰すために、関数 imfill を使用します。</p><pre class="codeinput">BWdfill = imfill(BWsdil, <span class="string">'holes'</span>);
figure, imshow(BWdfill);
title(<span class="string">'binary image with filled holes'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_04.png" alt=""> <h2>手順 5: 境界につながるオブジェクトの削除<a name="6"></a></h2><p>対象細胞は適切に区分化されましたが、検出されたのはこのオブジェクトのみではありません。イメージの境界につながるオブジェクトは、関数 imclearborder を使用して削除できます。関数 imclearborder の接続を 4 に設定して斜め方向のつながりを削除します。</p><pre class="codeinput">BWnobord = imclearborder(BWdfill, 4);
figure, imshow(BWnobord), title(<span class="string">'cleared border image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_05.png" alt=""> <h2>手順 6: オブジェクトの平滑化<a name="7"></a></h2><p>最後に、区分化されたオブジェクトが自然に見えるようにするために、ダイヤモンド構造化要素でイメージを 2 回縮退してオブジェクトを平滑にします。ダイヤモンド構造化要素は関数 <tt>strel</tt> を使用して作成します。</p><pre class="codeinput">seD = strel(<span class="string">'diamond'</span>,1);
BWfinal = imerode(BWnobord,seD);
BWfinal = imerode(BWfinal,seD);
figure, imshow(BWfinal), title(<span class="string">'segmented image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_06.png" alt=""> <p>区分化したオブジェクトを表示する別の方法は、区分化された細胞の周りに輪郭を描くことです。輪郭は関数 <tt>bwperim</tt> によって作成されます。</p><pre class="codeinput">BWoutline = bwperim(BWfinal);
Segout = I;
Segout(BWoutline) = 255;
figure, imshow(Segout), title(<span class="string">'outlined original image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcell_07.png" alt=""> <p class="footer">Copyright 2004-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Detecting a Cell Using Image Segmentation % An object can be easily detected in an image if the object has sufficient % contrast from the background. We use edge detection and basic morphology % tools to detect a prostate cancer cell. % % Copyright 2004-2005 The MathWorks, Inc.   %% Step 1: Read Image % Read in the |cell.tif| image, which is an image of a prostate cancer % cell.  I = imread('cell.tif'); figure, imshow(I), title('original image'); text(size(I,2),size(I,1)+15, ...     'Image courtesy of Alan Partin', ...     'FontSize',7,'HorizontalAlignment','right'); text(size(I,2),size(I,1)+25, ....     'Johns Hopkins University', ...     'FontSize',7,'HorizontalAlignment','right');  %% Step 2: Detect Entire Cell % Two cells are present in this image, but only one cell can be seen in its % entirety. We will detect this cell. Another word for object detection is % segmentation. The object to be segmented differs greatly in contrast from % the background image. Changes in contrast can be detected by operators that % calculate the gradient of an image.  The gradient image can be calculated % and a threshold can be applied to create a binary mask containing the segmented % cell.  First, we use |edge| and the Sobel operator to calculate the threshold % value. We then tune the threshold value and use |edge| again to obtain a % binary mask that contains the segmented cell.  [junk threshold] = edge(I, 'sobel'); fudgeFactor = .5; BWs = edge(I,'sobel', threshold * fudgeFactor); figure, imshow(BWs), title('binary gradient mask');  %% Step 3: Dilate the Image % The binary gradient mask shows lines of high contrast in the image. These % lines do not quite delineate the outline of the object of interest. % Compared to the original image, you can see gaps in the lines surrounding % the object in the gradient mask. These linear gaps will disappear if the % Sobel image is dilated using linear structuring elements, which we can % create with the |strel| function.  se90 = strel('line', 3, 90); se0 = strel('line', 3, 0);  %% % The binary gradient mask is dilated using the vertical structuring % element followed by the horizontal structuring element. The |imdilate| % function dilates the image.  BWsdil = imdilate(BWs, [se90 se0]); figure, imshow(BWsdil), title('dilated gradient mask');  %% Step 4: Fill Interior Gaps  % The dilated gradient mask shows the outline of the cell quite nicely, but % there are still holes in the interior of the cell. To fill these holes we % use the imfill function.  BWdfill = imfill(BWsdil, 'holes'); figure, imshow(BWdfill); title('binary image with filled holes');  %% Step 5: Remove Connected Objects on Border % The cell of interest has been successfully segmented, but it is not the % only object that has been found. Any objects that are connected to the % border of the image can be removed using the imclearborder function. The % connectivity in the imclearborder function was set to 4 to remove % diagonal connections.  BWnobord = imclearborder(BWdfill, 4); figure, imshow(BWnobord), title('cleared border image');  %% Step 6: Smoothen the Object % Finally, in order to make the segmented object look natural, we smoothen % the object by eroding the image twice with a diamond structuring element. % We create the diamond structuring element using the |strel| function.  seD = strel('diamond',1); BWfinal = imerode(BWnobord,seD); BWfinal = imerode(BWfinal,seD); figure, imshow(BWfinal), title('segmented image');  %% % An alternate method for displaying the segmented object would be to place % an outline around the segmented cell. The outline is created by the % |bwperim| function.  BWoutline = bwperim(BWfinal); Segout = I;  Segout(BWoutline) = 255;  figure, imshow(Segout), title('outlined original image');   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>