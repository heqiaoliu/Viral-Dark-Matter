
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>Lucy-Richardson アルゴリズムを使用したイメージのブレ除去</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexlucy.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexlucy">エディターで ipexlucy.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexlucy">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>Lucy-Richardson アルゴリズムを使用したイメージのブレ除去</h1><!--introduction--><p>Lucy-Richardson アルゴリズムは、点像分布関数 (ブレの演算子) が既知であり、ノイズについて入手できる情報がわずかであるか、またはまったくない場合にも効果的に使用できます。ブレとノイズを含むイメージは、高速の、減衰付き Lucy-Richardson アルゴリズムを繰り返すことで復元します。さらに光学システム (たとえばカメラ) の特性は、イメージの復元の品質向上に役立つ入力パラメーターとして使用することが可能です。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:イメージの読み込み</a></li><li><a href="#2">手順 2:ブレとノイズのシミュレーション</a></li><li><a href="#4">手順 3:ブレとノイズを含むイメージの復元</a></li><li><a href="#5">手順 4:復元の調査の反復</a></li><li><a href="#8">手順 5:減衰によるノイズの増大の制御</a></li><li><a href="#11">手順 6:サンプル イメージの作成</a></li><li><a href="#12">手順 7:ブレのシミュレーション</a></li><li><a href="#15">手順 8:WEIGHT 配列の提供</a></li><li><a href="#16">手順 9:細かくサンプリングされた PSF の提供</a></li></ul></div><h2>手順 1:イメージの読み込み<a name="1"></a></h2><p>この例では RGB イメージを読み込み、256 X 256 X 3 に小さく切り取ります。関数 <tt>deconvlucy</tt> は、任意の次元の配列を取り扱うことができます。</p><pre class="codeinput">I = imread(<span class="string">'board.tif'</span>);
I = I(50+[1:256],2+[1:256],:);
figure;imshow(I);title(<span class="string">'Original Image'</span>);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of courtesy of Alexander V. Panasyuk, Ph.D.'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
text(size(I,2),size(I,1)+25, <span class="keyword">...</span>
    <span class="string">'Harvard-Smithsonian Center for Astrophysics'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_01.png" alt=""> <h2>手順 2: ブレとノイズのシミュレーション<a name="2"></a></h2><p>ブレ (たとえばカメラの動きやフォーカス不足など) とノイズ (ランダム外乱など) を含む実世界のイメージをシミュレートします。 この例では、実際のイメージをガウス フィルターで (<tt>imfilter</tt> を使用して) 畳み込むことによってブレをシミュレートします。 ガウス フィルターは点像分布関数 <tt>PSF</tt> を表します。</p><pre class="codeinput">PSF = fspecial(<span class="string">'gaussian'</span>0.50.5);
Blurred = imfilter(I,PSF,<span class="string">'symmetric'</span>,<span class="string">'conv'</span>);
figure;imshow(Blurred);title(<span class="string">'Blurred'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_02.png" alt=""> <p>この例では、分散のガウス ノイズ <tt>V</tt> を、ブレを含んだイメージに (<tt>imnoise</tt> を使用して) 追加することでノイズをシミュレートします。ノイズ分散 <tt>V</tt> は、後で、アルゴリズムの減衰パラメーターの定義に使用されます。</p><pre class="codeinput">V = .002;
BlurredNoisy = imnoise(Blurred,<span class="string">'gaussian'</span>,0,V);
figure;imshow(BlurredNoisy);title(<span class="string">'Blurred &amp; Noisy'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_03.png" alt=""> <h2>手順 3:ブレとノイズを含むイメージの復元<a name="4"></a></h2><p>PSF を指定し、反復回数 5 (既定値は 10) のみを使用して、ブレとノイズを含むイメージを復元します。出力は、入力イメージと同じタイプの配列です。</p><pre class="codeinput">luc1 = deconvlucy(BlurredNoisy,PSF,5);
figure;imshow(luc1);title(<span class="string">'Restored Image, NUMIT = 5'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_04.png" alt=""> <h2>手順 4:復元の調査の反復<a name="5"></a></h2><p>結果として得られるイメージは、各反復と共に変化します。イメージの復元の変化を調べるには、デコンボリューションを行います。一連の反復を行い、その結果を確認したら、中止した場所から反復を再開します。これを行うには、入力イメージをセル配列の一部として渡す必要があります (たとえば、<tt>BlurredNoisy</tt> ではなく、<tt>{BlurredNoisy}</tt> を入力イメージ パラメーターとして渡すことで最初の一連の反復を開始します)。</p><pre class="codeinput">luc1_cell = deconvlucy({BlurredNoisy},PSF,5);
</pre><p>その場合、出力 <tt>luc1_cell</tt> はセル配列になります。セル出力は 4 つの数値配列から構成されます。その 1 つ目の配列は <tt>BlurredNoisy</tt> イメージ、2 つ目の配列はクラス double の復元されたイメージ、3 つ目の配列は最後の 1 つ前の反復の結果、4 つ目の配列は繰り返されたセットの内部パラメーターです。出力セル配列の 2 つ目の数値配列であるイメージ <tt>luc1_cell{2}</tt> は、手順 3 の出力配列であるイメージ <tt>luc1</tt> と同じであり、それらのクラスの例外が発生する可能性があります (セルの出力は常に、クラス double の復元されたイメージを与えます)。</p><p>反復を再開するには、前の関数呼び出しからの出力であるセル配列 <tt>luc1_cell</tt> を取得し、関数 <tt>deconvlucy</tt> に渡します。既定の反復回数 (<tt>NUMIT</tt> = 10) を使用します。復元されたイメージは、合計 15 回の反復の結果です。</p><pre class="codeinput">luc2_cell = deconvlucy(luc1_cell,PSF);
luc2 = im2uint8(luc2_cell{2});
figure;imshow(luc2);title(<span class="string">'Restored Image, NUMIT = 15'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_05.png" alt=""> <h2>手順 5:減衰によるノイズの増大の制御<a name="8"></a></h2><p>最新のイメージ <tt>luc2</tt> は、15 回の反復の結果です。5 回の反復時点の前の結果に比べてシャープになっていますが、イメージに &quot;染みが付いた&quot; ように見えます。染みは実際のどの構造にも対応しませんが (実際のイメージと比較して)、データ内のノイズをできる限り近似しようとする場合に生じます。</p><p>ノイズの増大を制御するには、<tt>DAMPAR</tt> パラメーターを指定することにより減衰オプションを使用します。<tt>DAMPAR</tt> は入力イメージと同じクラスです。アルゴリズムにより、ノイズに比べて差異が小さい領域でのモデルの変化が抑制されます。この例で使用される <tt>DAMPAR</tt> は、ノイズの 3 つの標準偏差に等しくなります。イメージがよりスムーズであることに注目してください。</p><pre class="codeinput">DAMPAR = im2uint8(3*sqrt(V));
luc3 = deconvlucy(BlurredNoisy,PSF,15,DAMPAR);
figure;imshow(luc3);
title(<span class="string">'Restored Image with Damping, NUMIT = 15'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_06.png" alt=""> <p>このデモの以下の部分では、(簡略化と高速化のために) シミュレートした星のイメージを使用して、関数 deconvlucy の <tt>WEIGHT</tt> および <tt>SUBSMPL</tt> 入力パラメーターについて考察します。</p><h2>手順 6:サンプル イメージの作成<a name="11"></a></h2><p>以下の例では、4 つの星の白黒イメージを作成します。</p><pre class="codeinput">I = zeros(32);I(5,5)=1;I(10,3)=1;I(27,26)=1;I(29,25)=1;
figure;imshow(1-I,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTickLabel'</span>,[],<span class="string">'YTickLabel'</span>,[],<span class="keyword">...</span>
<span class="string">'XTick'</span>,[7 24],<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YTick'</span>,[5 28],<span class="string">'YGrid'</span>,<span class="string">'on'</span>);
title(<span class="string">'Data'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_07.png" alt=""> <h2>手順 7:ブレのシミュレーション<a name="12"></a></h2><p>以下の例は、ガウス フィルターである <tt>PSF</tt> を作成し、実際のイメージと畳み込むことで、星のイメージのブレをシミュレートします。</p><pre class="codeinput">PSF = fspecial(<span class="string">'gaussian'</span>,15,3);
Blurred = imfilter(I,PSF,<span class="string">'conv'</span>,<span class="string">'sym'</span>);
</pre><p>ここで、星のイメージの部分のみ確認できるカメラをシミュレートします (ブレのみが確認されます)。重み関数配列 WEIGHT を作成します。これは、ブレを含むイメージの中心部分にある 1 (点線内にある &quot;良好な&quot; ピクセル) と、エッジにあるゼロ (信号を受信しない &quot;不正&quot; ピクセル) で構成されます。</p><pre class="codeinput">WT = zeros(32);WT(6:27,8:23) = 1;
CutImage = Blurred.*WT;
</pre><p>境界に関連付けられたリンギングを減らすには、PSF が指定された関数 edgetaper を適用します。</p><pre class="codeinput">CutEdged = edgetaper(CutImage,PSF);
figure;imshow(1-CutEdged,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTickLabel'</span>,[],<span class="string">'YTickLabel'</span>,[],<span class="keyword">...</span>
<span class="string">'XTick'</span>,[7 24],<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YTick'</span>,[5 28],<span class="string">'YGrid'</span>,<span class="string">'on'</span>);
title(<span class="string">'Observed'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_08.png" alt=""> <h2>手順 8:WEIGHT 配列の提供<a name="15"></a></h2><p>アルゴリズムは、イメージの復元中に、WEIGHT 配列に従って各ピクセル値を重み付けします。この例では、&quot;不正&quot; ピクセル値を最適化から除外すると同時に、中心のピクセルの値のみを使用します (ここでは、WEIGHT = 1)。ただし、アルゴリズムは、カメラの視点のエッジを超えて、信号パワーをこれらの &quot;不正&quot; ピクセルの位置に入れることができます。解決された星の位置の精度に注意してください。</p><pre class="codeinput">luc4 = deconvlucy(CutEdged,PSF,300,0,WT);
figure;imshow(1-luc4,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTickLabel'</span>,[],<span class="string">'YTickLabel'</span>,[],<span class="keyword">...</span>
<span class="string">'XTick'</span>,[7 24],<span class="string">'XGrid'</span>,<span class="string">'on'</span>,<span class="string">'YTick'</span>,[5 28],<span class="string">'YGrid'</span>,<span class="string">'on'</span>);
title(<span class="string">'Restored'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_09.png" alt=""> <h2>手順 9:細かくサンプリングされた PSF の提供<a name="16"></a></h2><p>関数 deconvlucy は、細かくサンプリングされた (SUBSMPL 倍細かい) PSF が指定された、アンダーサンプルされたイメージを復元できます.不完全に解決されたイメージおよび PSF をシミュレートするために、以下の例では、各次元において、<tt>Blurred</tt> イメージと元の PSF を、2 つのピクセルを 1 つにして分類します。</p><pre class="codeinput">Binned = squeeze(sum(reshape(Blurred,[2 16 2 16])));
BinnedImage = squeeze(sum(Binned,2));
Binned = squeeze(sum(reshape(PSF(1:14,1:14),[2 7 2 7])));
BinnedPSF = squeeze(sum(Binned,2));
figure;imshow(1-BinnedImage,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[]);
title(<span class="string">'Binned Observed'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_10.png" alt=""> <p>アンダーサンプリングされた PSF である <tt>BinnedPSF</tt> を使用して、アンダーサンプリングされたイメージである <tt>BinnedImage</tt> を復元します。<tt>luc5</tt> イメージは 3 つの星のみを区別することに注目してください。</p><pre class="codeinput">luc5 = deconvlucy(BinnedImage,BinnedPSF,100);
figure;imshow(1-luc5,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[]);
title(<span class="string">'Poor PSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_11.png" alt=""> <p>以下の例では、アンダーサンプルされたイメージ (<tt>BinnedImage</tt>) を復元します。今回はより細かい PSF (SUBSMPL 倍細かいグリッド上で定義) を使用します。再構築されたイメージ (<tt>luc6</tt>) では、星の位置の精度が高くなります。イメージの右下隅にある 2 つの星の間でパワーを分散する方法に注目してください。これは、前の復元と同様に、1 つではなく、2 つの明るいオブジェクトが存在する可能性を示しています。</p><pre class="codeinput">luc6 = deconvlucy(BinnedImage,PSF,100,[],[],[],2);
figure;imshow(1-luc6,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
set(gca,<span class="string">'Visible'</span>,<span class="string">'on'</span>,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[]);
title(<span class="string">'Fine PSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexlucy_12.png" alt=""> <p class="footer">Copyright 2004-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Deblurring Images Using the Lucy-Richardson Algorithm  % The Lucy-Richardson algorithm can be used effectively when the % point-spread function PSF (blurring operator) is known, but little or no % information is available for the noise. The blurred and noisy image is % restored by the iterative, accelerated, damped Lucy-Richardson algorithm. % The additional optical system (e.g. camera) characteristics can be used % as input parameters to improve the quality of the image restoration.   % Copyright 2004-2005 The MathWorks, Inc.  %% Step 1: Read Image % The example reads in an RGB image and crops it to be 256-by-256-by-3. The % |deconvlucy| function can handle arrays of any dimension.  I = imread('board.tif'); I = I(50+[1:256],2+[1:256],:); figure;imshow(I);title('Original Image'); text(size(I,2),size(I,1)+15, ...     'Image courtesy of courtesy of Alexander V. Panasyuk, Ph.D.', ...     'FontSize',7,'HorizontalAlignment','right'); text(size(I,2),size(I,1)+25, ...     'Harvard-Smithsonian Center for Astrophysics', ...     'FontSize',7,'HorizontalAlignment','right');  %% Step 2: Simulate a Blur and Noise % Simulate a real-life image that could be blurred (e.g., due to camera % motion or lack of focus) and noisy (e.g., due to random disturbances). % The example simulates the blur by convolving a Gaussian filter with the % true image (using |imfilter|). The Gaussian filter then represents a % point-spread function, |PSF|.  PSF = fspecial('gaussian',5,5); Blurred = imfilter(I,PSF,'symmetric','conv'); figure;imshow(Blurred);title('Blurred');  %% % The example simulates the noise by adding a Gaussian noise of variance % |V| to the blurred image (using |imnoise|). The noise variance |V| is used % later to define a damping parameter of the algorithm.   V = .002; BlurredNoisy = imnoise(Blurred,'gaussian',0,V); figure;imshow(BlurredNoisy);title('Blurred & Noisy');  %% Step 3: Restore the Blurred and Noisy Image % Restore the blurred and noisy image providing the PSF and using only 5 % iterations (default is 10). The output is an array of the same type as % the input image.  luc1 = deconvlucy(BlurredNoisy,PSF,5); figure;imshow(luc1);title('Restored Image, NUMIT = 5');  %% Step 4: Iterate to Explore the Restoration % The resulting image changes with each iteration. To investigate the % evolution of the image restoration, you can do the deconvolution in % steps: do a set of iterations, see the result, and then resume the % iterations from where they were stopped. To do so, the input image has to % be passed as a part of a cell array (e.g., start first set of iterations % by passing in |{BlurredNoisy}| instead of |BlurredNoisy| as input image % parameter).   luc1_cell = deconvlucy({BlurredNoisy},PSF,5);  %% % In that case the output, |luc1_cell|, becomes a cell array. The cell output % consists of four numeric arrays, where the first is the |BlurredNoisy| % image, the second is the restored image of class double, the third array % is the result of the one-before-last iteration, and the fourth array is % an internal parameter of the iterated set. The second numeric array of % the output cell-array, image |luc1_cell{2}|, is identical to the output % array of the Step 3, image |luc1|, with a possible exception of their class % (the cell output always gives the restored image of class double).  %% % To resume the iterations, take the output from the previous function % call, the cell-array |luc1_cell|, and pass it into the |deconvlucy| function. % Use the default number of iterations (|NUMIT| = 10). The restored image is % the result of a total of 15 iterations.  luc2_cell = deconvlucy(luc1_cell,PSF); luc2 = im2uint8(luc2_cell{2}); figure;imshow(luc2);title('Restored Image, NUMIT = 15');  %% Step 5: Control Noise Amplification by Damping % The latest image, |luc2|, is the result of 15 iterations. Although it is % sharper than the earlier result from 5 iterations, the image develops a % "speckled" appearance. The speckles do not correspond to any real % structures (compare it to the true image), but instead are the result of % fitting the noise in the data too closely.   %% % To control the noise amplification, use the damping option by specifying % the |DAMPAR| parameter. |DAMPAR| has to be of the same class as the input % image. The algorithm dampens changes in the model in regions where the % differences are small compared with the noise. The |DAMPAR| used here % equals 3 standard deviations of the noise. Notice that the image is % smoother.  DAMPAR = im2uint8(3*sqrt(V)); luc3 = deconvlucy(BlurredNoisy,PSF,15,DAMPAR); figure;imshow(luc3); title('Restored Image with Damping, NUMIT = 15');  %% % The next part of this demo explores the |WEIGHT| and |SUBSMPL| input % parameters of the deconvlucy function, using a simulated star image (for % simplicity & speed).  %% Step 6: Create Sample Image % The example creates a black/white image of four stars.   I = zeros(32);I(5,5)=1;I(10,3)=1;I(27,26)=1;I(29,25)=1; figure;imshow(1-I,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTickLabel',[],'YTickLabel',[],... 'XTick',[7 24],'XGrid','on','YTick',[5 28],'YGrid','on'); title('Data');  %% Step 7: Simulate a Blur % The example simulates a blur of the image of the stars by creating a % Gaussian filter, |PSF|, and convolving it with the true image.  PSF = fspecial('gaussian',15,3); Blurred = imfilter(I,PSF,'conv','sym');  %% % Now simulate a camera that can only observe part of the stars' images % (only the blur is seen). Create a weighting function array, WEIGHT, that % consists of ones in the central part of the Blurred image ("good" pixels, % located within the dashed lines) and zeros at the edges ("bad" pixels - % those that do not receive the signal).  WT = zeros(32);WT(6:27,8:23) = 1; CutImage = Blurred.*WT;  %% % To reduce the ringing associated with borders, apply the edgetaper % function with the given PSF.  CutEdged = edgetaper(CutImage,PSF); figure;imshow(1-CutEdged,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTickLabel',[],'YTickLabel',[],... 'XTick',[7 24],'XGrid','on','YTick',[5 28],'YGrid','on'); title('Observed');  %% Step 8: Provide the WEIGHT Array % The algorithm weights each pixel value according to the WEIGHT array % while restoring the image. In our example, only the values of the central % pixels are used (where WEIGHT = 1), while the "bad" pixel values are % excluded from the optimization. However, the algorithm can place the % signal power into the location of these "bad" pixels, beyond the edge of % the camera's view. Notice the accuracy of the resolved star positions.  luc4 = deconvlucy(CutEdged,PSF,300,0,WT); figure;imshow(1-luc4,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTickLabel',[],'YTickLabel',[],... 'XTick',[7 24],'XGrid','on','YTick',[5 28],'YGrid','on'); title('Restored');  %% Step 9: Provide a finer-sampled PSF % deconvlucy can restore undersampled image given a finer sampled PSF % (finer by SUBSMPL times). To simulate the poorly resolved image and PSF, % the example bins the |Blurred| image and the original PSF, two pixels in % one, in each dimension.   Binned = squeeze(sum(reshape(Blurred,[2 16 2 16]))); BinnedImage = squeeze(sum(Binned,2)); Binned = squeeze(sum(reshape(PSF(1:14,1:14),[2 7 2 7]))); BinnedPSF = squeeze(sum(Binned,2)); figure;imshow(1-BinnedImage,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTick',[],'YTick',[]); title('Binned Observed');  %% % Restore the undersampled image, |BinnedImage|, using the undersampled PSF, % |BinnedPSF|. Notice that the |luc5| image distinguishes only 3 stars.  luc5 = deconvlucy(BinnedImage,BinnedPSF,100); figure;imshow(1-luc5,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTick',[],'YTick',[]); title('Poor PSF');  %% % The next example restores the undersampled image (|BinnedImage|), this time % using the finer PSF (defined on a SUBSMPL-times finer grid). The % reconstructed image (|luc6|) resolves the position of the stars more % accurately. Note how it distributes power between the two stars in the % lower right corner of the image. This hints at the existence of two % bright objects, instead of one, as in the previous restoration.   luc6 = deconvlucy(BinnedImage,PSF,100,[],[],[],2); figure;imshow(1-luc6,[],'InitialMagnification','fit'); set(gca,'Visible','on','XTick',[],'YTick',[]); title('Fine PSF');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>