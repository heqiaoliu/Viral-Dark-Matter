
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Measuring Regions in Grayscale Images</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="ipexprops.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexprops">Open ipexprops.m in the Editor</a></div><div class="right"><a href="matlab:echodemo ipexprops">Run in the Command Window</a></div></div><div class="content"><h1>Measuring Regions in Grayscale Images</h1><!--introduction--><p>The function <tt>regionprops</tt> is very useful for measuring the properties of objects in a binary image.  There are documentation examples and product demos showing how to do this.</p><p>But sometimes you need to process pixel values in the "original" grayscale image.  In other words, suppose your process is something like this:</p><p>1. Segment grayscale image to get a binary image of objects.</p><p>2. Analyze the original grayscale pixel values corresponding to each object in the binary image.</p><p>This demo shows you how to accomplish this workflow using <tt>regionprops</tt>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Create Synthetic Image</a></li><li><a href="#2">Step 2: Create a Binary Image</a></li><li><a href="#3">Step 3: Calculate Object Properties Using Pixel Values of Grayscale Image</a></li><li><a href="#5">Step 4: Calculate Custom Pixel Value-Based Properties</a></li></ul></div><h2>Step 1: Create Synthetic Image<a name="1"></a></h2><p>Create a grayscale image that contains some distinct regions.</p><pre class="codeinput">I = propsSynthesizeImage;
imshow(I)
title(<span class="string">'Synthetic Image'</span>)
</pre><img vspace="5" hspace="5" src="ipexprops_01.png" alt=""> <h2>Step 2: Create a Binary Image<a name="2"></a></h2><p>Segment the grayscale image by creating a binary image containing the objects in the image.</p><pre class="codeinput">BW = I &gt; 0;
imshow(BW)
title(<span class="string">'Binary Image'</span>)
</pre><img vspace="5" hspace="5" src="ipexprops_02.png" alt=""> <h2>Step 3: Calculate Object Properties Using Pixel Values of Grayscale Image<a name="3"></a></h2><p>The <tt>regionprops</tt> function supports several properties that can be used with grayscale images, including 'WeightedCentroid', 'MeanIntensity', 'MinIntensity', and 'MaxIntensity'.  These properties use the original pixel values of the objects for their calculations.</p><p>For example, you can use <tt>regionprops</tt> to calculate both the centroid and weighted centroid of objects in the image. Note how you pass in the binary image (<tt>BW</tt>) containing your objects and the original grayscale image (<tt>I</tt>) as arguments into <tt>regionprops</tt>.</p><pre class="codeinput">s = regionprops(BW, I, {<span class="string">'Centroid'</span>,<span class="string">'WeightedCentroid'</span>});
</pre><p>To compare the weighted centroid locations with the unweighted centroid locations, display the original image and then, using the <tt>hold</tt> and <tt>plot</tt> functions, superimpose the centroids on the image.</p><pre class="codeinput">imshow(I)
title(<span class="string">'Weighted (red) and Unweighted (blue) Centroid Locations'</span>);
hold <span class="string">on</span>
numObj = numel(s);
<span class="keyword">for</span> k = 1 : numObj
    plot(s(k).WeightedCentroid(1), s(k).WeightedCentroid(2), <span class="string">'r*'</span>);
    plot(s(k).Centroid(1), s(k).Centroid(2), <span class="string">'bo'</span>);
<span class="keyword">end</span>
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="ipexprops_03.png" alt=""> <h2>Step 4: Calculate Custom Pixel Value-Based Properties<a name="5"></a></h2><p>You can use the 'PixelValues' property to do custom calculations based on the pixel values of the original grayscale image. The 'PixelValues' property returns a vector containing the grayscale values of pixels in a region.</p><p>As an example, calculate the standard deviation of each region.</p><pre class="codeinput">s = regionprops(BW, I, {<span class="string">'Centroid'</span>,<span class="string">'PixelValues'</span>,<span class="string">'BoundingBox'</span>});
imshow(I);
title(<span class="string">'Standard Deviation of Regions'</span>);
hold <span class="string">on</span>
<span class="keyword">for</span> k = 1 : numObj
    s(k).StandardDeviation = std(double(s(k).PixelValues));
    text(s(k).Centroid(1),s(k).Centroid(2), <span class="keyword">...</span>
        sprintf(<span class="string">'%2.1f'</span>, s(k).StandardDeviation), <span class="keyword">...</span>
        <span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'Color'</span>,<span class="string">'r'</span>);
<span class="keyword">end</span>
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="ipexprops_04.png" alt=""> <p>This figure shows the standard deviation measurement superimposed on each object in the image. You can also view the results in other ways, for example as a bar plot showing the standard deviation by label number.</p><pre class="codeinput">figure
bar(1:numObj,[s.StandardDeviation]);
xlabel(<span class="string">'Region Label Number'</span>);
ylabel(<span class="string">'Standard Deviation'</span>);
</pre><img vspace="5" hspace="5" src="ipexprops_05.png" alt=""> <p>You can use the plot to determine how to partition the data. For example, the following code identifies objects with a standard deviation lower than 50.</p><pre class="codeinput">sStd = [s.StandardDeviation];
lowStd = find(sStd &lt; 50);

imshow(I);
title(<span class="string">'Objects Having Standard Deviation &lt; 50'</span>);
hold <span class="string">on</span>;
<span class="keyword">for</span> k = 1 : length(lowStd)
    rectangle(<span class="string">'Position'</span>, s(lowStd(k)).BoundingBox, <span class="keyword">...</span>
        <span class="string">'EdgeColor'</span>,<span class="string">'y'</span>);
<span class="keyword">end</span>
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="ipexprops_06.png" alt=""> <p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Measuring Regions in Grayscale Images
% The function |regionprops| is very useful for measuring the properties of
% objects in a binary image.  There are documentation examples and product
% demos showing how to do this.
%
% But sometimes you need to process pixel values in the "original"
% grayscale image.  In other words, suppose your process is something like
% this:
%
% 1. Segment grayscale image to get a binary image of objects.
%
% 2. Analyze the original grayscale pixel values corresponding to each
% object in the binary image.
%
% This demo shows you how to accomplish this workflow using |regionprops|.
%
% Copyright 2007-2009 The MathWorks, Inc.

%% Step 1: Create Synthetic Image
% Create a grayscale image that contains some distinct regions.

I = propsSynthesizeImage;
imshow(I)
title('Synthetic Image')

%% Step 2: Create a Binary Image
% Segment the grayscale image by creating a binary image containing the
% objects in the image. 

BW = I > 0;
imshow(BW)
title('Binary Image')

%% Step 3: Calculate Object Properties Using Pixel Values of Grayscale Image
% The |regionprops| function supports several properties that can be used
% with grayscale images, including 'WeightedCentroid', 'MeanIntensity',
% 'MinIntensity', and 'MaxIntensity'.  These properties use the original
% pixel values of the objects for their calculations.  
%
% For example, you can use |regionprops| to calculate both the centroid and
% weighted centroid of objects in the image. Note how you pass in the
% binary image (|BW|) containing your objects and the original grayscale
% image (|I|) as arguments into |regionprops|.

s = regionprops(BW, I, {'Centroid','WeightedCentroid'});

%%
% To compare the weighted centroid locations with the unweighted centroid
% locations, display the original image and then, using the |hold| and
% |plot| functions, superimpose the centroids on the image. 

imshow(I)
title('Weighted (red) and Unweighted (blue) Centroid Locations'); 
hold on
numObj = numel(s);
for k = 1 : numObj
    plot(s(k).WeightedCentroid(1), s(k).WeightedCentroid(2), 'r*');
    plot(s(k).Centroid(1), s(k).Centroid(2), 'bo');
end
hold off

%% Step 4: Calculate Custom Pixel Value-Based Properties
% You can use the 'PixelValues' property to do custom calculations based on
% the pixel values of the original grayscale image. The 'PixelValues'
% property returns a vector containing the grayscale values of pixels in a
% region.
%
% As an example, calculate the standard deviation of each region.

s = regionprops(BW, I, {'Centroid','PixelValues','BoundingBox'});
imshow(I);
title('Standard Deviation of Regions');
hold on
for k = 1 : numObj
    s(k).StandardDeviation = std(double(s(k).PixelValues));
    text(s(k).Centroid(1),s(k).Centroid(2), ...
        sprintf('%2.1f', s(k).StandardDeviation), ...
        'EdgeColor','b','Color','r');
end
hold off

%%
% This figure shows the standard deviation measurement superimposed on each
% object in the image. You can also view the results in other ways,
% for example as a bar plot showing the standard deviation by label number. 

figure
bar(1:numObj,[s.StandardDeviation]);
xlabel('Region Label Number');
ylabel('Standard Deviation');

%%
% You can use the plot to determine how to partition the data. For example,
% the following code identifies objects with a standard deviation lower
% than 50.

sStd = [s.StandardDeviation];
lowStd = find(sStd < 50);

imshow(I);
title('Objects Having Standard Deviation < 50');
hold on;
for k = 1 : length(lowStd)
    rectangle('Position', s(lowStd(k)).BoundingBox, ...
        'EdgeColor','y');
end
hold off;

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>