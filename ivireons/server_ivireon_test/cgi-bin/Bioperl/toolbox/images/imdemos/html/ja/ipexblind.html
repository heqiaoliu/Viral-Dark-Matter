
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ブラインド デコンボリューション アルゴリズムを使用したイメージのブレの除去</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexblind.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexblind">エディターで ipexblind.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexblind">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>ブラインド デコンボリューション アルゴリズムを使用したイメージのブレの除去</h1><!--introduction--><p>ブラインド デコンボリューション アルゴリズムは、歪み (ブレとノイズ) に関する情報が未知の場合でも、効果的に機能します。アルゴリズムは、イメージと点像分布関数 (PSF) を同時に復元します。高速化された減衰付きの Richardson-Lucy アルゴリズムが各反復において使用されます。さらに光学システム (カメラなど) の特性を入力パラメーターとして使用すると、イメージの復元の品質向上に役立ちます。PSF の制約は、ユーザー指定の関数から渡すことができます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: ブレのシミュレーション</a></li><li><a href="#3">手順 3: ブレたイメージを異なるサイズの PSF を使用して復元</a></li><li><a href="#7">手順 4: 復元された PSF の解析</a></li><li><a href="#11">手順 5: 復元の改善</a></li><li><a href="#15">手順 6: PSF 復元に追加の制約を使用</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p>例では強度イメージを読み込みます。関数 <tt>deconvblind</tt> は任意の次元の配列を処理できます。</p><pre class="codeinput">I = imread(<span class="string">'cameraman.tif'</span>);
figure;imshow(I);title(<span class="string">'Original Image'</span>);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of Massachusetts Institute of Technology'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_01.png" alt=""> <h2>手順 2:  ブレのシミュレーション<a name="2"></a></h2><p>カメラの移動や焦点が合わないためにブレる可能性がある現実のイメージをシミュレートします。 この例では、実際のイメージをガウス フィルターで (<tt>imfilter</tt> を使用して) 畳み込むことによって、ブレをシミュレートします。 ガウス フィルターは点像分布関数 <tt>PSF</tt> で表されます。</p><pre class="codeinput">PSF = fspecial(<span class="string">'gaussian'</span>,7,10);
Blurred = imfilter(I,PSF,<span class="string">'symmetric'</span>,<span class="string">'conv'</span>);
figure;imshow(Blurred);title(<span class="string">'Blurred Image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_02.png" alt=""> <h2>手順 3: ブレたイメージを異なるサイズの PSF を使用して復元<a name="3"></a></h2><p>真の PSF のサイズを認識することが重要であることを説明するために、この例では 3 つの復元を行います。毎回 PSF の再生は一様な配列 (1 の配列) から開始します。</p><p>最初の復元 <tt>J1</tt> および <tt>P1</tt> は、小さな配列 <tt>UNDERPSF</tt> を使用して、初期 PSF を推定します。UNDERPSF 配列のサイズは、各次元で真の PSF よりも 4 ピクセル短くなります。</p><pre class="codeinput">UNDERPSF = ones(size(PSF)-4);
[J1 P1] = deconvblind(Blurred,UNDERPSF);
figure;imshow(J1);title(<span class="string">'Deblurring with Undersized PSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_03.png" alt=""> <p>2 番目の復元 <tt>J2</tt> および <tt>P2</tt> は、1 の配列 <tt>OVERPSF</tt> を使用して、各次元で真の PSF よりも 4 ピクセル長い初期の PSF を推定します。</p><pre class="codeinput">OVERPSF = padarray(UNDERPSF,[4 4],<span class="string">'replicate'</span>,<span class="string">'both'</span>);
[J2 P2] = deconvblind(Blurred,OVERPSF);
figure;imshow(J2);title(<span class="string">'Deblurring with Oversized PSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_04.png" alt=""> <p>3 番目の復元 <tt>J3</tt> および <tt>P3</tt> は、1 の配列 <tt>INITPSF</tt> を使用して、真の PSF とサイズがまったく等しい初期の PSF を推定します。</p><pre class="codeinput">INITPSF = padarray(UNDERPSF,[2 2],<span class="string">'replicate'</span>,<span class="string">'both'</span>);
[J3 P3] = deconvblind(Blurred,INITPSF);
figure;imshow(J3);title(<span class="string">'Deblurring with INITPSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_05.png" alt=""> <h2>手順 4: 復元された PSF の解析<a name="7"></a></h2><p>3 つの復元すべてで PSF の生成も行われます。次の図は、再生された PSF が初期 PSF の正しいサイズの推定にどのように役立つかを示します。真の PSF であるガウス フィルターでは、値は中央 (白) で最大になり境界 (黒) では小さくなります。</p><pre class="codeinput">figure;
subplot(221);imshow(PSF,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'True PSF'</span>);
subplot(222);imshow(P1,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed Undersized PSF'</span>);
subplot(223);imshow(P2,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed Oversized PSF'</span>);
subplot(224);imshow(P3,[],<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
title(<span class="string">'Reconstructed true PSF'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_06.png" alt=""> <p>最初の復元で再生された PSF、<tt>P1</tt> は、明らかに制限サイズに収まりません。境界に強い信号変動があります。対応するイメージ、<tt>J1</tt> は、ブレたイメージ <tt>Blurred</tt> と比べて鮮明さが改善されていません。</p><p>2 番目の復元で再生された PSF、<tt>P2</tt> は、端がとても滑らかになっています。これは、復元ではよりサイズの小さい PSF を処理できることを意味します。対応するイメージ、<tt>J2</tt>、はいくらかブレが除去されていますが、リンギングによって強く損なわれています。</p><p>最後に、3 番目の復元で再生された PSF、<tt>P3</tt> は、<tt>P1</tt> と <tt>P2</tt> の中間にあるといえます。配列 <tt>P3</tt> は真の PSF にとてもよく似ています。対応するイメージ、<tt>J3</tt> は、大幅に改善されていますが、リンギングによって損なわれています。</p><h2>手順 5: 復元の改善<a name="11"></a></h2><p>復元されたイメージ (<tt>J3</tt>) のリンギングは、イメージ内のコントラスト強度がはっきりしている部分とイメージの境界沿いに発生しています。この例では、重み関数を指定してリンギングの影響を低減する方法を示します。アルゴリズムにより <tt>WEIGHT</tt> 配列に従って各ピクセルに重みが加えられ、イメージと PSF を復元します。この例では、最初に関数 edge を使用して &quot;シャープな&quot; ピクセルを見つけます。試行錯誤により、望ましいしきい値レベルは 0.3 であることがわかりました。</p><pre class="codeinput">WEIGHT = edge(I,<span class="string">'sobel'</span>,.3);
</pre><p>範囲を広げるために、<tt>imdilate</tt> を使用して構造化要素 <tt>se</tt> を渡します。</p><pre class="codeinput">se = strel(<span class="string">'disk'</span>,2);
WEIGHT = 1-double(imdilate(WEIGHT,se));
</pre><p>また、境界に近いピクセルには値 0 が割り当てられます。</p><pre class="codeinput">WEIGHT([1:3 end-[0:2]],:) = 0;
WEIGHT(:,[1:3 end-[0:2]]) = 0;
figure;imshow(WEIGHT);title(<span class="string">'Weight array'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_07.png" alt=""> <p>イメージは、<tt>WEIGHT</tt> 配列と増加した反復回数 (30) を使用し deconvblind を呼び出して復元します。ほぼすべてのリンギングが取り除かれました。</p><pre class="codeinput">[J P] = deconvblind(Blurred,INITPSF,30,[],WEIGHT);
figure;imshow(J);title(<span class="string">'Deblurred Image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_08.png" alt=""> <h2>手順 6: PSF 復元に追加の制約を使用<a name="15"></a></h2><p>例では、PSF に追加の制約を指定する方法を示します。次の関数 <tt>FUN</tt> は、修正された PSF 配列を返します。deconvblind はこの配列を次の反復に使用します。</p><p>この例では、<tt>FUN</tt> は、各次元で <tt>P1</tt> および <tt>P2</tt> 個のピクセルを切り取り、配列にゼロを付加して元のサイズに戻すことにより PSF を修正します。この操作は PSF の中央の値を変更しませんが、PSF サイズを <tt>2*P1</tt> ピクセルと <tt>2*P2</tt> ピクセル分効果的に縮小します。</p><pre class="codeinput">P1 = 2;
P2 = 2;
FUN = @(PSF) padarray(PSF(P1+1:end-P1,P2+1:end-P2),[P1 P2]);
</pre><p>無名関数 <tt>FUN</tt> は最後に <tt>deconvblind</tt> に渡されます。</p><p>この例では、初期 PSFのサイズ <tt>OVERPSF</tt> は、真の PSF よりも 4 ピクセル大きくなっています。<tt>FUN</tt> でパラメーターを P1=2 および P2=2 に設定すると、<tt>OVERPSF</tt> の有効なスペースを事実上真の PSF と同じサイズにします。そのため、結果 <tt>JF</tt> および <tt>PF</tt> は、手順 4 で適切なサイズの PSF を使用して <tt>FUN</tt> を呼び出さない deconvolution の結果 <tt>J</tt> および <tt>P</tt> と似ています。</p><pre class="codeinput">[JF PF] = deconvblind(Blurred,OVERPSF,30,[],WEIGHT,FUN);
figure;imshow(JF);title(<span class="string">'Deblurred Image'</span>);
</pre><img vspace="5" hspace="5" src="../ipexblind_09.png" alt=""> <p>サイズの大きな初期 PSF <tt>OVERPSF</tt> を使用し、制約関数 <tt>FUN</tt> を使用しなかった場合、結果のイメージは手順 3 で得られた不十分な結果 <tt>J2</tt> と同様のものになっていたでしょう。</p><p>この例では <tt>DAMPAR</tt> や <tt>READOUT</tt> など、<tt>FUN</tt> の前の未指定パラメーターは省略することができ、プレース ホルダー ([]) は不要なことに注意してください。</p><p class="footer">Copyright 2004-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Deblurring Images Using the Blind Deconvolution Algorithm  % The Blind Deconvolution Algorithm can be used effectively when no % information about the distortion (blurring and noise) is known. The % algorithm restores the image and the point-spread function (PSF) % simultaneously. The accelerated, damped Richardson-Lucy algorithm is used % in each iteration. Additional optical system (e.g. camera) % characteristics can be used as input parameters that could help to % improve the quality of the image restoration. PSF constraints can be % passed in through a user-specified function  % Copyright 2004-2005 The MathWorks, Inc.  %% Step 1: Read Image % The example reads in an intensity image. The |deconvblind| function can % handle arrays of any dimension.  I = imread('cameraman.tif'); figure;imshow(I);title('Original Image'); text(size(I,2),size(I,1)+15, ...     'Image courtesy of Massachusetts Institute of Technology', ...     'FontSize',7,'HorizontalAlignment','right');  %% Step 2: Simulate a Blur  % Simulate a real-life image that could be blurred (e.g., due to camera % motion or lack of focus). The example simulates the blur by convolving a % Gaussian filter with the true image (using |imfilter|). The Gaussian filter % then represents a point-spread function, |PSF|.  PSF = fspecial('gaussian',7,10); Blurred = imfilter(I,PSF,'symmetric','conv'); figure;imshow(Blurred);title('Blurred Image');  %% Step 3: Restore the Blurred Image Using PSFs of Various Sizes  % To illustrate the importance of knowing the size of the true PSF, this % example performs three restorations. Each time the PSF reconstruction % starts from a uniform arrayREPLACE_WITH_DASH_DASHan array of ones.  %% % The first restoration, |J1| and |P1|, uses an undersized array, |UNDERPSF|, for % an initial guess of the PSF. The size of the UNDERPSF array is 4 pixels % shorter in each dimension than the true PSF.   UNDERPSF = ones(size(PSF)-4); [J1 P1] = deconvblind(Blurred,UNDERPSF); figure;imshow(J1);title('Deblurring with Undersized PSF');  %% % The second restoration, |J2| and |P2|, uses an array of ones, |OVERPSF|, for an % initial PSF that is 4 pixels longer in each dimension than the true PSF.  OVERPSF = padarray(UNDERPSF,[4 4],'replicate','both'); [J2 P2] = deconvblind(Blurred,OVERPSF); figure;imshow(J2);title('Deblurring with Oversized PSF');  %% % The third restoration, |J3| and |P3|, uses an array of ones, |INITPSF|, for an % initial PSF that is exactly of the same size as the true PSF.  INITPSF = padarray(UNDERPSF,[2 2],'replicate','both'); [J3 P3] = deconvblind(Blurred,INITPSF); figure;imshow(J3);title('Deblurring with INITPSF');  %% Step 4: Analyzing the Restored PSF % All three restorations also produce a PSF. The following pictures show % how the analysis of the reconstructed PSF might help in guessing the % right size for the initial PSF. In the true PSF, a Gaussian filter, the % maximum values are at the center (white) and diminish at the borders (black).  figure; subplot(221);imshow(PSF,[],'InitialMagnification','fit'); title('True PSF'); subplot(222);imshow(P1,[],'InitialMagnification','fit'); title('Reconstructed Undersized PSF'); subplot(223);imshow(P2,[],'InitialMagnification','fit'); title('Reconstructed Oversized PSF'); subplot(224);imshow(P3,[],'InitialMagnification','fit'); title('Reconstructed true PSF');  %%  % The PSF reconstructed in the first restoration, |P1|, obviously does not % fit into the constrained size. It has a strong signal variation at the % borders. The corresponding image, |J1|, does not show any improved clarity % vs. the blurred image, |Blurred|.  %% % The PSF reconstructed in the second restoration, |P2|, becomes very smooth % at the edges. This implies that the restoration can handle a PSF of a % smaller size. The corresponding image, |J2|, shows some deblurring but it % is strongly corrupted by the ringing.  %% % Finally, the PSF reconstructed in the third restoration, |P3|, is somewhat % intermediate between |P1| and |P2|. The array, |P3|, resembles the true PSF % very well. The corresponding image, |J3|, shows significant improvement; % however it is still corrupted by the ringing.  %% Step 5: Improving the Restoration % The ringing in the restored image, |J3|, occurs along the areas of sharp % intensity contrast in the image and along the image borders. This example % shows how to reduce the ringing effect by specifying a weighting % function. The algorithm weights each pixel according to the |WEIGHT| array % while restoring the image and the PSF. In our example, we start by % finding the "sharp" pixels using the edge function. By trial and error, % we determine that a desirable threshold level is 0.3.  WEIGHT = edge(I,'sobel',.3);  %% % To widen the area, we use |imdilate| and pass in a structuring element, |se|.  se = strel('disk',2); WEIGHT = 1-double(imdilate(WEIGHT,se));  %% % The pixels close to the borders are also assigned the value 0.  WEIGHT([1:3 end-[0:2]],:) = 0; WEIGHT(:,[1:3 end-[0:2]]) = 0; figure;imshow(WEIGHT);title('Weight array');  %% % The image is restored by calling deconvblind with the |WEIGHT| array and an % increased number of iterations (30). Almost all the ringing is suppressed.  [J P] = deconvblind(Blurred,INITPSF,30,[],WEIGHT); figure;imshow(J);title('Deblurred Image');  %% Step 6: Using Additional Constraints on the PSF Restoration % The example shows how you can specify additional constraints on the PSF. % The function, |FUN|, below returns a modified PSF array which deconvblind % uses for the next iteration.  % % In this example, |FUN| modifies the PSF by cropping it by |P1| and |P2| number % of pixels in each dimension, and then padding the array back to its % original size with zeros. This operation does not change the values in % the center of the PSF, but effectively reduces the PSF size by |2*P1| and % |2*P2| pixels.   P1 = 2; P2 = 2; FUN = @(PSF) padarray(PSF(P1+1:end-P1,P2+1:end-P2),[P1 P2]);  %% % The anonymous function, |FUN|, is passed into |deconvblind| last.  %% % In this example, the size of the initial PSF, |OVERPSF|, is 4 pixels larger % than the true PSF. Setting P1=2 and P2=2 as parameters in |FUN| % effectively makes the valuable space in |OVERPSF| the same size as the true % PSF. Therefore, the outcome, |JF| and |PF|, is similar to the result of % deconvolution with the right sized PSF and no |FUN| call, |J| and |P|, from % step 4.  [JF PF] = deconvblind(Blurred,OVERPSF,30,[],WEIGHT,FUN); figure;imshow(JF);title('Deblurred Image');  %% % If we had used the oversized initial PSF, |OVERPSF|, without the % constraining function, |FUN|, the resulting image would be similar to the % unsatisfactory result, |J2|, achieved in Step 3. % % Note, that any unspecified parameters before |FUN| can be omitted, such as % |DAMPAR| and |READOUT| in this example, without requiring a place holder, % ([]).   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>