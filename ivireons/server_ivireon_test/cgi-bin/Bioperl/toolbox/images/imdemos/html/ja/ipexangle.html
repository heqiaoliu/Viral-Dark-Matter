
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>交点角度の測定</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexangle.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexangle">エディターで ipexangle.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexangle">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>交点角度の測定</h1><!--introduction--><p>マシン ビジョン アプリケーションに共通の作業は、画像取得および画像処理手法を使ったハンズフリー測定です。目的は、境界トレース ルーチンである <tt>bwtraceboundary</tt> を使用して 2 つの ビームの角度と交点を測定することです。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: 関心領域の抽出</a></li><li><a href="#3">手順 3: イメージのしきい値処理</a></li><li><a href="#4">手順 4: 各境界の始点の検出</a></li><li><a href="#6">手順 5: 境界のトレース</a></li><li><a href="#7">手順 6: 境界に線を一致させる</a></li><li><a href="#8">手順 7: 交点角度の測定</a></li><li><a href="#9">手順 8: 交点の検出</a></li><li><a href="#10">手順 9: 結果のプロット</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p><tt>gantrycrane.png</tt> を読み込み、2 つの注目ビームを矢印で示します。これはブリッジを組み立てるときに使用するガントリー クレーンのイメージです。</p><pre class="codeinput">RGB = imread(<span class="string">'gantrycrane.png'</span>);
imshow(RGB);

text(size(RGB,2),size(RGB,1)+15,<span class="string">'Image courtesy of Jeff Mather'</span>,<span class="keyword">...</span>
     <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);

line([300 328],[85 103],<span class="string">'color'</span>,[1 1 0]);
line([268 255],[85 140],<span class="string">'color'</span>,[1 1 0]);

text(150,72,<span class="string">'Measure the angle between these beams'</span>,<span class="string">'Color'</span>,<span class="string">'y'</span>,<span class="keyword">...</span>
     <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
</pre><img vspace="5" hspace="5" src="../ipexangle_01.png" alt=""> <h2>手順 2: 関心領域の抽出<a name="2"></a></h2><p>イメージを抽出し、前に選択したガントリー クレーンのビームのみを取得します。この手順は、2 つの金属ビームのエッジを抽出しやすくします。</p><pre class="codeinput"><span class="comment">% you can obtain the coordinates of the rectangular region using</span>
<span class="comment">% pixel information displayed by imtool</span>
start_row = 34;
start_col = 208;

cropRGB = RGB(start_row:163, start_col:400, :);

imshow(cropRGB)

<span class="comment">% Store (X,Y) offsets for later use; subtract 1 so that each offset will</span>
<span class="comment">% correspond to the last pixel before the region of interest</span>
offsetX = start_col-1;
offsetY = start_row-1;
</pre><img vspace="5" hspace="5" src="../ipexangle_02.png" alt=""> <h2>手順 3: イメージのしきい値処理<a name="3"></a></h2><p>続いて <tt>bwtraceboundary</tt> を使用してエッジ座標を抽出するために、イメージを白黒画像に変換します。</p><pre class="codeinput">I = rgb2gray(cropRGB);
threshold = graythresh(I);
BW = im2bw(I,threshold);
BW = ~BW;  <span class="comment">% complement the image (objects of interest must be white)</span>
imshow(BW)
</pre><img vspace="5" hspace="5" src="../ipexangle_03.png" alt=""> <h2>手順 4: 各境界の始点の検出<a name="4"></a></h2><p><tt>bwtraceboundary</tt> ルーチンでは境界上に 1 つのポイントを指定する必要があります。このポイントは、境界のトレース プロセスの開始位置として使用します。</p><p>下のビームのエッジを抽出するには、イメージ内の列を選択し、バックグランド ピクセルからオブジェクト ピクセルに遷移が起きるまで確認します。後で <tt>bwtraceboundary</tt> ルーチンで使用できるように、この位置を保存しておきます。この手順を別のビームでも繰り返しますが、今度は横方向にトレースします。</p><pre class="codeinput">dim = size(BW);

<span class="comment">% horizontal beam</span>
col1 = 4;
row1 = min(find(BW(:,col1)));

<span class="comment">% angled beam</span>
row2 = 12;
col2 = min(find(BW(row2,:)));
</pre><h2>手順 5: 境界のトレース<a name="6"></a></h2><p><tt>bwtraceboundary</tt> ルーチンは、境界ポイントの (X, Y) 位置を抽出するために使用します。角度および交点の計算精度を最大にするには、ビーム エッジのポイントをできるだけ多く抽出することが重要です。ポイントの数を実験的に決める必要があります。水平バーの始点は北から南にスキャンして得られたので、検索ステップはオブジェクトの外側 ('North' など) に向かうように設定するのが最も安全です。</p><pre class="codeinput">boundary1 = bwtraceboundary(BW, [row1, col1], <span class="string">'N'</span>, 8, 70);

<span class="comment">% set the search direction to counterclockwise, in order to trace downward.</span>
boundary2 = bwtraceboundary(BW, [row2, col2], <span class="string">'E'</span>, 8, 90,<span class="string">'counter'</span>);

imshow(RGB); hold <span class="string">on</span>;

<span class="comment">% apply offsets in order to draw in the original image</span>
plot(offsetX+boundary1(:,2),offsetY+boundary1(:,1),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2);
plot(offsetX+boundary2(:,2),offsetY+boundary2(:,1),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2);
</pre><img vspace="5" hspace="5" src="../ipexangle_04.png" alt=""> <h2>手順 6: 境界に線を一致させる<a name="7"></a></h2><p>(X,Y) 座標の組み合わせは前の手順で得られましたが、すべてのポイントが線上に正確に配置されているわけではありません。角度と交点を計算するにはどのポイントを使用するのが良いでしょうか。取得したポイントがすべて等しく重要であると仮定して、境界ピクセルの位置に線を一致させます。</p><p>線の式は y = [x 1]*[a; b] です。<tt>polyfit</tt> を使用し、最小二乗法で 'a' と 'b' のパラメータ値を求めることができます。</p><pre class="codeinput">ab1 = polyfit(boundary1(:,2), boundary1(:,1), 1);
ab2 = polyfit(boundary2(:,2), boundary2(:,1), 1);
</pre><h2>手順 7: 交点角度の測定<a name="8"></a></h2><p>ドット積を使用して角度を見つけます。</p><pre class="codeinput">vect1 = [1 ab1(1)]; <span class="comment">% create a vector based on the line equation</span>
vect2 = [1 ab2(1)];
dp = dot(vect1, vect2);

<span class="comment">% compute vector lengths</span>
length1 = sqrt(sum(vect1.^2));
length2 = sqrt(sum(vect2.^2));

<span class="comment">% obtain the larger angle of intersection in degrees</span>
angle = 180-acos(dp/(length1*length2))*180/pi
</pre><pre class="codeoutput">
angle =

  129.4971

</pre><h2>手順 8: 交点の検出<a name="9"></a></h2><p>交点座標 (X,Y) を取得するために 2 つの方程式を解きます。</p><pre class="codeinput">intersection = [1 ,-ab1(1); 1, -ab2(1)] \ [ab1(2); ab2(2)];
<span class="comment">% apply offsets in order to compute the location in the original,</span>
<span class="comment">% i.e. not cropped, image.</span>
intersection = intersection + [offsetY; offsetX]
</pre><pre class="codeoutput">
intersection =

  143.0917
  295.7494

</pre><h2>手順 9: 結果のプロット<a name="10"></a></h2><pre class="codeinput">inter_x = intersection(2);
inter_y = intersection(1);

<span class="comment">% draw an &quot;X&quot; at the point of intersection</span>
plot(inter_x,inter_y,<span class="string">'yx'</span>,<span class="string">'LineWidth'</span>,2);

text(inter_x-60, inter_y-30, [sprintf(<span class="string">'%1.3f'</span>,angle),<span class="string">'{\circ}'</span>],<span class="keyword">...</span>
     <span class="string">'Color'</span>,<span class="string">'y'</span>,<span class="string">'FontSize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'bold'</span>);

interString = sprintf(<span class="string">'(%2.1f,%2.1f)'</span>, inter_x, inter_y);

text(inter_x-10, inter_y+20, interString,<span class="keyword">...</span>
<span class="string">'Color'</span>,<span class="string">'y'</span>,<span class="string">'FontSize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'bold'</span>);
</pre><img vspace="5" hspace="5" src="../ipexangle_05.png" alt=""> <p class="footer">Copyright 1993-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Measuring Angle of Intersection % A common task in machine vision applications is hands-free measurement  % using image acquisition and image processing techniques. % Your goal is to measure the angle and point of intersection between two % beams using |bwtraceboundary|, which is a boundary tracing routine. % % Copyright 1993-2005 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:28:48 $  %% Step 1: Load Image % Read in |gantrycrane.png| and draw arrows pointing to two beams of  % interest. It is an image of a gantry crane used to assemble a bridge.  RGB = imread('gantrycrane.png'); imshow(RGB);  text(size(RGB,2),size(RGB,1)+15,'Image courtesy of Jeff Mather',...      'FontSize',7,'HorizontalAlignment','right');  line([300 328],[85 103],'color',[1 1 0]); line([268 255],[85 140],'color',[1 1 0]);  text(150,72,'Measure the angle between these beams','Color','y',...      'FontWeight', 'bold');  %% Step 2: Extract the Region of Interest % Crop the image to obtain only the beams of the gantry crane chosen % earlier.  This step will make it easier to extract  % the edges of the two metal beams.  % you can obtain the coordinates of the rectangular region using  % pixel information displayed by imtool start_row = 34; start_col = 208;  cropRGB = RGB(start_row:163, start_col:400, :);  imshow(cropRGB)  % Store (X,Y) offsets for later use; subtract 1 so that each offset will % correspond to the last pixel before the region of interest offsetX = start_col-1; offsetY = start_row-1;  %% Step 3: Threshold the Image % Convert the image to black and white for subsequent extraction of the edge % coordinates using |bwtraceboundary| routine.  I = rgb2gray(cropRGB); threshold = graythresh(I); BW = im2bw(I,threshold); BW = ~BW;  % complement the image (objects of interest must be white) imshow(BW)  %% Step 4: Find Initial Point on Each Boundary % The |bwtraceboundary| routine requires that you specify a single % point on a boundary. This point is used as the starting location for  % the boundary tracing process.  %% % To extract the edge of the lower beam, pick a column in the image and % inspect it until a transition from a background pixel to the object % pixel occurs.  Store this location for later use in |bwtraceboundary| % routine. Repeat this procedure for the other beam, but this time tracing % horizontally.  dim = size(BW);  % horizontal beam col1 = 4; row1 = min(find(BW(:,col1)));  % angled beam row2 = 12; col2 = min(find(BW(row2,:)));  %% Step 5: Trace the Boundaries % The |bwtraceboundary| routine is used to extract (X, Y) locations of  % the boundary points. In order to maximize the accuracy of the angle % and point of intersection calculations, it is important to extract as many % points belonging to the beam edges as possible. You should determine the  % number of points experimentally. Since the initial point for the horizontal % bar was obtained by scanning from north to south, it is safest to set the % initial search step to point towards the outside of the object, % i.e. 'North'.  boundary1 = bwtraceboundary(BW, [row1, col1], 'N', 8, 70);  % set the search direction to counterclockwise, in order to trace downward. boundary2 = bwtraceboundary(BW, [row2, col2], 'E', 8, 90,'counter');  imshow(RGB); hold on;  % apply offsets in order to draw in the original image plot(offsetX+boundary1(:,2),offsetY+boundary1(:,1),'g','LineWidth',2); plot(offsetX+boundary2(:,2),offsetY+boundary2(:,1),'g','LineWidth',2);  %% Step 6: Fit Lines to the Boundaries % Although (X,Y) coordinates pairs were obtained in the previous step, % not all of the points lie exactly on a line. Which ones  % should be used to compute the angle and point of intersection? % Assuming that all of the acquired points are equally important, % fit lines to the boundary pixel locations. % % The equation for a line is y = [x 1]*[a; b]. You can solve for parameters % 'a' and 'b' in the least-squares sense by using |polyfit|.  ab1 = polyfit(boundary1(:,2), boundary1(:,1), 1); ab2 = polyfit(boundary2(:,2), boundary2(:,1), 1);  %% Step 7: Find the Angle of Intersection % Use the dot product to find the angle.  vect1 = [1 ab1(1)]; % create a vector based on the line equation vect2 = [1 ab2(1)]; dp = dot(vect1, vect2);  % compute vector lengths length1 = sqrt(sum(vect1.^2)); length2 = sqrt(sum(vect2.^2));  % obtain the larger angle of intersection in degrees angle = 180-acos(dp/(length1*length2))*180/pi  %% Step 8: Find the Point of Intersection % Solve the system of two equations in order to obtain (X,Y) coordinates % of the intersection point.  intersection = [1 ,-ab1(1); 1, -ab2(1)] \ [ab1(2); ab2(2)]; % apply offsets in order to compute the location in the original, % i.e. not cropped, image. intersection = intersection + [offsetY; offsetX]  %% Step 9: Plot the Results. %  inter_x = intersection(2); inter_y = intersection(1);  % draw an "X" at the point of intersection plot(inter_x,inter_y,'yx','LineWidth',2);  text(inter_x-60, inter_y-30, [sprintf('%1.3f',angle),'{\circ}'],...      'Color','y','FontSize',14,'FontWeight','bold');  interString = sprintf('(%2.1f,%2.1f)', inter_x, inter_y);  text(inter_x-10, inter_y+20, interString,...      'Color','y','FontSize',14,'FontWeight','bold');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>