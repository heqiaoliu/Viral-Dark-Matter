
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>コントラスト強調方法</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexcontrast.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexcontrast">エディターで ipexcontrast.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexcontrast">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>コントラスト強調方法</h1><!--introduction--><p>Image Processing Toolbox™ は、さまざまな画像強調ルーチンを含んでいます。3 つの関数 <tt>imadjust</tt>、<tt>histeq</tt>、および <tt>adapthisteq</tt> は、コントラストの強調に特に適しています。このデモは、グレースケールとトゥルーカラー イメージの強調での使用を比較します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:イメージの読み込み</a></li><li><a href="#2">手順 2:イメージのリサイズ</a></li><li><a href="#3">手順 3:グレースケール イメージの強調</a></li><li><a href="#10">手順 4:カラー イメージの強調</a></li></ul></div><h2>手順 1:イメージの読み込み<a name="1"></a></h2><p>2 つのグレースケール イメージ <tt>pout.tif</tt> および <tt>tire.tif</tt> を読み込みます。また、インデックス付き RGB イメージ <tt>shadow.tif</tt> も読み込みます。</p><pre class="codeinput">pout = imread(<span class="string">'pout.tif'</span>);
tire = imread(<span class="string">'tire.tif'</span>);
[X map] = imread(<span class="string">'shadow.tif'</span>);
shadow = ind2rgb(X,map); <span class="comment">% convert to truecolor</span>
</pre><h2>手順 2:イメージのリサイズ<a name="2"></a></h2><p>イメージの比較を簡単に行うには、同じ幅を持つようにイメージをリサイズします。その高さをスケーリングして、縦横比を維持します。</p><pre class="codeinput">width = 210;
images = {pout, tire, shadow};

<span class="keyword">for</span> k = 1:3
  dim = size(images{k});
  images{k} = imresize(images{k},[width*dim(1)/dim(2) width],<span class="string">'bicubic'</span>);
<span class="keyword">end</span>

pout = images{1};
tire = images{2};
shadow = images{3};
</pre><h2>手順 3:グレースケール イメージの強調<a name="3"></a></h2><p>既定の設定を使用して、以下の 3 つの方法の有効性を比較します。</p><div><ul><li><b><tt>imadjust</tt></b> は、既定の設定では、データの 1% が入力データの低い強度と高い強度で飽和するように、入力強度イメージの値を新しい値にマッピングすることでイメージのコントラストを高くします。</li><li><b><tt>histeq</tt></b> は、ヒストグラム均等化を行います。出力イメージのヒストグラムが指定のヒストグラム (既定の設定では一様分布) にほぼ一致するように、強度イメージの値を変換することにより、イメージのコントラストを強調します。</li><li><b><tt>adapthisteq</tt></b> は、コントラストに制限を付けて適応ヒストグラム均等化を実行します。<tt>histeq</tt> とは異なり、全体のイメージよりもむしろ小さなデータ領域 (タイル) を処理します。各出力領域のヒストグラムは指定のヒストグラム (既定の設定では一様分布) とほぼ一致するように各タイルのコントラストが強調できます。コントラストの強調は、イメージ内に存在するノイズの増幅を避けるために制限されます。</li></ul></div><pre class="codeinput">pout_imadjust = imadjust(pout);
pout_histeq = histeq(pout);
pout_adapthisteq = adapthisteq(pout);

imshow(pout);
title(<span class="string">'Original'</span>);

figure, imshow(pout_imadjust);
title(<span class="string">'Imadjust'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_01.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_02.png" alt=""> <pre class="codeinput">figure, imshow(pout_histeq);
title(<span class="string">'Histeq'</span>);

figure, imshow(pout_adapthisteq);
title(<span class="string">'Adapthisteq'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_03.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_04.png" alt=""> <pre class="codeinput">tire_imadjust = imadjust(tire);
tire_histeq = histeq(tire);
tire_adapthisteq = adapthisteq(tire);

figure, imshow(tire);
title(<span class="string">'Original'</span>);

figure, imshow(tire_imadjust);
title(<span class="string">'Imadjust'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_05.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_06.png" alt=""> <pre class="codeinput">figure, imshow(tire_histeq);
title(<span class="string">'Histeq'</span>);

figure, imshow(tire_adapthisteq);
title(<span class="string">'Adapthisteq'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_07.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_08.png" alt=""> <p><tt>imadjust</tt> はタイヤのイメージにはほとんど影響を与えませんが、膨れっ面のイメージの場合には大きな変化をもたらしていることに注意してください。<tt>pout.tif</tt> および <tt>tire.tif</tt> のヒストグラムのプロットにより、最初のイメージのほとんどのピクセルがヒストグラムの中心に集中していることが明らかです。一方、<tt>tire.tif</tt> の場合、値は既に最小値 0 から最大値 255 の間に広がっています。そのため、<tt>imadjust</tt> は、イメージのコントラストの調整には有効ではありません。</p><pre class="codeinput">figure, imhist(pout), title(<span class="string">'pout.tif'</span>);
figure, imhist(tire), title(<span class="string">'tire.tif'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_09.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_10.png" alt=""> <p>一方、ヒストグラム均等化は、両方のイメージを変化させます。以前は隠れていた多くの特徴、特にタイヤの破片粒子が露出します。残念ながら、同時に、強調は両方のイメージのいくつかの領域を過飽和させます。タイヤの中心、子供の顔の部分、およびジャケットが白っぽくなったことに注目してください。</p><p>タイヤのイメージに注目すると、イメージの他の領域のコントラストを強調しながらも、車輪の中心は、ほぼ同じ明るさにとどまることが望ましいです。このようにするには、異なる変換をイメージの異なる部分に適用する必要があります。<tt>adapthisteq</tt> で実行されるコントラストに制限を付けた適応ヒストグラム均等化手法がこれを実現します。アルゴリズムは、イメージの部分を解析し、適切な変換を計算します。コントラスト強調のレベルの制限も設定できるので、<tt>histeq</tt> の基本のヒストグラムの均等化方法による過飽和を防ぐことができます。これは、このデモで最も高度な手法です。</p><h2>手順 4:カラー イメージの強調<a name="10"></a></h2><p>カラー イメージのコントラスト強調は通常、イメージを色空間に変換することにより行います。色空間では、イメージの強調をいずれかのコンポーネントとして持っています。たとえば、色空間の 1 つは L*a*b* です。色変換関数を使用して、イメージを RGB から L*a*b* 色空間に変換し、イメージの明度レイヤ 'L*' で作業します。明度の操作は、元の色を維持しながらも、ピクセルの強度に影響を与えます。</p><pre class="codeinput">srgb2lab = makecform(<span class="string">'srgb2lab'</span>);
lab2srgb = makecform(<span class="string">'lab2srgb'</span>);

shadow_lab = applycform(shadow, srgb2lab); <span class="comment">% convert to L*a*b*</span>

<span class="comment">% the values of luminosity can span a range from 0 to 100; scale them</span>
<span class="comment">% to [0 1] range (appropriate for MATLAB(R) intensity images of class double)</span>
<span class="comment">% before applying the three contrast enhancement techniques</span>
max_luminosity = 100;
L = shadow_lab(:,:,1)/max_luminosity;

<span class="comment">% replace the luminosity layer with the processed data and then convert</span>
<span class="comment">% the image back to the RGB colorspace</span>
shadow_imadjust = shadow_lab;
shadow_imadjust(:,:,1) = imadjust(L)*max_luminosity;
shadow_imadjust = applycform(shadow_imadjust, lab2srgb);

shadow_histeq = shadow_lab;
shadow_histeq(:,:,1) = histeq(L)*max_luminosity;
shadow_histeq = applycform(shadow_histeq, lab2srgb);

shadow_adapthisteq = shadow_lab;
shadow_adapthisteq(:,:,1) = adapthisteq(L)*max_luminosity;
shadow_adapthisteq = applycform(shadow_adapthisteq, lab2srgb);

figure, imshow(shadow);
title(<span class="string">'Original'</span>);

figure, imshow(shadow_imadjust);
title(<span class="string">'Imadjust'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_11.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_12.png" alt=""> <pre class="codeinput">figure, imshow(shadow_histeq);
title(<span class="string">'Histeq'</span>);

figure, imshow(shadow_adapthisteq);
title(<span class="string">'Adapthisteq'</span>);
</pre><img vspace="5" hspace="5" src="../ipexcontrast_13.png" alt=""> <img vspace="5" hspace="5" src="../ipexcontrast_14.png" alt=""> <p class="footer">Copyright 1993-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Contrast Enhancement Techniques % The Image Processing Toolbox(TM) contains several image enhancement  % routines. Three functions are particularly suitable for contrast  % enhancement: |imadjust|, |histeq|, and |adapthisteq|. % This demo compares their use for enhancing grayscale and % truecolor images. % % Copyright 1993-2007 The MathWorks, Inc. % $Revision: 1.1.4.4.2.1 $  $Date: 2010/07/29 21:28:50 $   %% Step 1: Load Images % Read in two grayscale images:  |pout.tif| and |tire.tif|. Also read in % an indexed RGB image: |shadow.tif|.  pout = imread('pout.tif'); tire = imread('tire.tif'); [X map] = imread('shadow.tif'); shadow = ind2rgb(X,map); % convert to truecolor  %% Step 2: Resize Images % To make the image comparison easier, resize the images to have the % same width.  Preserve their aspect ratios by scaling their heights.  width = 210; images = {pout, tire, shadow};  for k = 1:3   dim = size(images{k});   images{k} = imresize(images{k},[width*dim(1)/dim(2) width],'bicubic'); end  pout = images{1}; tire = images{2}; shadow = images{3};  %% Step 3: Enhance Grayscale Images % Using the default settings, compare the effectiveness of the  % following three techniques: % % * *|imadjust|* increases the contrast of the image by mapping the values  %              of the input intensity image to new values such that,  %              by default, 1% of the data is saturated at low and high  %              intensities of the input data. % * *|histeq|* performs histogram equalization. It enhances the contrast  %            of images by transforming the values in an intensity image %            so that the histogram of the output image %            approximately matches a specified histogram (uniform distribution %            by default). % * *|adapthisteq|* performs contrast-limited adaptive histogram equalization. %            Unlike |histeq|, it operates on small data regions (tiles) %            rather than the entire image. Each tile's contrast is  %            enhanced so that the histogram of each output region approximately %            matches the specified histogram (uniform distribution by default). %            The contrast enhancement can be limited in order to avoid %            amplifying the noise which might be present in the image. %  pout_imadjust = imadjust(pout); pout_histeq = histeq(pout); pout_adapthisteq = adapthisteq(pout);  imshow(pout); title('Original');  figure, imshow(pout_imadjust); title('Imadjust');  %%  figure, imshow(pout_histeq); title('Histeq');  figure, imshow(pout_adapthisteq); title('Adapthisteq');  %%  tire_imadjust = imadjust(tire); tire_histeq = histeq(tire); tire_adapthisteq = adapthisteq(tire);  figure, imshow(tire); title('Original');  figure, imshow(tire_imadjust); title('Imadjust');  %%  figure, imshow(tire_histeq); title('Histeq');  figure, imshow(tire_adapthisteq); title('Adapthisteq');  %% % Notice that |imadjust| had little effect on the image of the % tire, but it caused a drastic change in the case of pout. % Plotting the histograms of |pout.tif| and |tire.tif| reveals that most  % of the pixels in the first image are concentrated in the center of % the histogram, while in the case of |tire.tif|, the values are already % spread out between the minimum of 0 and maximum of 255 thus preventing  % |imadjust| from being effective in adjusting the contrast of the image.  %% figure, imhist(pout), title('pout.tif'); figure, imhist(tire), title('tire.tif');  %% % Histogram equalization, on the other hand, substantially changes  % both images. Many of the previously hidden features are exposed,  % especially the debris particles on the tire. Unfortunately, at the same  % time, the enhancement over-saturates several areas of both images. % Notice how the center of the tire, part of the child's face, % and the jacket became washed out. % % Concentrating on the image of the tire, it would be % preferable for the center of the wheel to stay at about the same % brightness while enhancing the contrast in other areas of the image. % In order for that to happen, a different transformation would have to % be applied to different portions of the image. The Contrast-Limited Adaptive  % Histogram Equalization technique, implemented in |adapthisteq|, can % accomplish this.  The algorithm analyzes portions of the image and computes  % the appropriate transformations. A limit on the level of contrast % enhancement can also be set, thus preventing the over-saturation caused  % by the basic histogram equalization method of |histeq|. This is the  % most sophisticated technique in this demonstration.  %% Step 4: Enhance Color Images % Contrast enhancement of color images is typically done by transforming an % image to a color space that has image intensity as one of its components. % One such color space is L*a*b*. Use color transform functions to convert  % the image from RGB to L*a*b* color space, and then work on  % the luminosity layer 'L*' of the image. Manipulating luminosity affects % the intensity of the pixels, while preserving the original colors.  srgb2lab = makecform('srgb2lab'); lab2srgb = makecform('lab2srgb');  shadow_lab = applycform(shadow, srgb2lab); % convert to L*a*b*  % the values of luminosity can span a range from 0 to 100; scale them % to [0 1] range (appropriate for MATLAB(R) intensity images of class double)  % before applying the three contrast enhancement techniques max_luminosity = 100; L = shadow_lab(:,:,1)/max_luminosity;  % replace the luminosity layer with the processed data and then convert % the image back to the RGB colorspace shadow_imadjust = shadow_lab; shadow_imadjust(:,:,1) = imadjust(L)*max_luminosity; shadow_imadjust = applycform(shadow_imadjust, lab2srgb);  shadow_histeq = shadow_lab; shadow_histeq(:,:,1) = histeq(L)*max_luminosity; shadow_histeq = applycform(shadow_histeq, lab2srgb);  shadow_adapthisteq = shadow_lab; shadow_adapthisteq(:,:,1) = adapthisteq(L)*max_luminosity; shadow_adapthisteq = applycform(shadow_adapthisteq, lab2srgb);  figure, imshow(shadow); title('Original');  figure, imshow(shadow_imadjust); title('Imadjust');  %%  figure, imshow(shadow_histeq); title('Histeq');  figure, imshow(shadow_adapthisteq); title('Adapthisteq');   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>