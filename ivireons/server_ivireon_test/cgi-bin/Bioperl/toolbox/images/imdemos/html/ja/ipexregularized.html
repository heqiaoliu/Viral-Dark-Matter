
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>正則化フィルターを使ったイメージのブレ除去</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexregularized.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexregularized">エディターで ipexregularized.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexregularized">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>正則化フィルターを使ったイメージのブレ除去</h1><!--introduction--><p>正則化のデコンボリューションは、制限が復元された (すなわち、滑らかな) イメージに適用され、加法性ノイズについての制限情報が既知の場合、有効に利用することができます。不鮮明でノイズのあるイメージは、正則化フィルターを使った制約付き最小二乗復元アルゴリズムにより復元されます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: ブレとノイズのシミュレーション</a></li><li><a href="#4">手順 3: ブレとノイズを含むイメージの回復</a></li><li><a href="#8">手順 4: ノイズ増幅およびリンギングの低減</a></li><li><a href="#9">手順 5: ラグランジュ乗数の使用</a></li><li><a href="#12">手順 6: 異なる制約の使用</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p>この例では RGB イメージを読み込み、256 X 256 X 3 に小さく切り取ります。deconvreg 関数は、任意の次元の配列を取り扱うことができます。</p><pre class="codeinput">I = imread(<span class="string">'tissue.png'</span>);
I = I(125+[1:256],1:256,:);
figure;imshow(I);title(<span class="string">'Original Image'</span>);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of Alan Partin, Johns Hopkins University'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_01.png" alt=""> <h2>手順 2: ブレとノイズのシミュレーション<a name="2"></a></h2><p>ブレ (たとえばカメラの動きやフォーカス不足など) とノイズ (ランダム外乱など) を含む実世界のイメージをシミュレートします。この例では、実際のイメージをガウス フィルターで (関数 imfilter を使用して) 畳み込むことによってブレをシミュレートします。ガウス フィルターは、点像分布関数 PSF を表します。</p><pre class="codeinput">PSF = fspecial(<span class="string">'gaussian'</span>,11,5);
Blurred = imfilter(I,PSF,<span class="string">'conv'</span>);
figure;imshow(Blurred);
title(<span class="string">'Blurred'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_02.png" alt=""> <p>分散 V のガウスノイズをブレを含むイメージに追加することで (関数 imnoise を使用)、ノイズをシミュレートします。</p><pre class="codeinput">V = .02;
BlurredNoisy = imnoise(Blurred,<span class="string">'gaussian'</span>,0,V);
figure;imshow(BlurredNoisy);
title(<span class="string">'Blurred &amp; Noisy'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_03.png" alt=""> <h2>手順 3: ブレとノイズを含むイメージの復元<a name="4"></a></h2><p>ノイズ強度 NP を 3 番目の入力パラメーターとして提供し、ブレとノイズを含むイメージを復元します。ノイズ強度の値 NP へのアルゴリズムの感度を示すために、この例では、3 つの復元を実行します。</p><p>最初の復元 reg1 では真の NP を使用します。この例では、2 つのパラメーターが出力されることに注意してください。最初の戻り値 reg1 は、復元されたイメージです。2 番目の戻り値 LAGRA は、deconvreg が収束されるスカラーであるラグランジュ乗数です。この値は後にデモで使用されます。</p><pre class="codeinput">NP = V*prod(size(I)); <span class="comment">% noise power</span>
[reg1 LAGRA] = deconvreg(BlurredNoisy,PSF,NP);
figure,imshow(reg1),title(<span class="string">'Restored with NP'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_04.png" alt=""> <p>2 番目の復元 reg2 では、わずかに過大推定されたノイズ強度を使用するので、解像度が不足します。</p><pre class="codeinput">reg2 = deconvreg(BlurredNoisy,PSF,NP*1.3);
figure;imshow(reg2);
title(<span class="string">'Restored with larger NP'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_05.png" alt=""> <p>3 番目の復元 reg3 では、過小評価された NP 値が使用されます。その結果、ノイズ増幅が大幅に増大し、イメージの境界線からの &quot;リンギング&quot; が発生します。</p><pre class="codeinput">reg3 = deconvreg(BlurredNoisy,PSF,NP/1.3);
figure;imshow(reg3);
title(<span class="string">'Restored with smaller NP'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_06.png" alt=""> <h2>手順 4: ノイズ増幅およびリンギングの低減<a name="8"></a></h2><p>デコンボリューションの前に関数 edgetaper を呼び出して、ノイズ増幅およびイメージの境界線の &quot;リンギング&quot; を低減します。イメージ復元のノイズ強度パラメーターへの感度が下がっていることに注意してください。以前の例からのノイズ強度値 NP を使用します。</p><pre class="codeinput">Edged = edgetaper(BlurredNoisy,PSF);
reg4 = deconvreg(Edged,PSF,NP/1.3);
figure;imshow(reg4);
title(<span class="string">'Edgetaper effect'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_07.png" alt=""> <h2>手順 5: ラグランジュ乗数の使用<a name="9"></a></h2><p>最適解がすでに見つかり、対応するラグランジュ乗数 LAGRA が与えられていると仮定して、ブレとノイズを含むイメージを復元します。この場合、ノイズ強度 NP に対して渡された値は無視されます。</p><p>LAGRA 値へのアルゴリズムの感度を示すために、この例では、3 つの復元を実行します。最初の復元 (reg5) では、以前の解からの LAGRA 出力 (手順 3 の最初の解の LAGRA 出力) を使用します。</p><pre class="codeinput">reg5 = deconvreg(Edged,PSF,[],LAGRA);
figure;imshow(reg5);
title(<span class="string">'Restored with LAGRA'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_08.png" alt=""> <p>2 番目の復元 (reg6) では、制約の有意性を増大させる 100*LAGRA が使用されます。既定の設定では、イメージの過大な平滑化をもたらします。</p><pre class="codeinput">reg6 = deconvreg(Edged,PSF,[],LAGRA*100);
figure;imshow(reg6);
title(<span class="string">'Restored with large LAGRA'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_09.png" alt=""> <p>3 番目の復元では、制約 (イメージの平滑化要件のセット) を弱める LAGRA/100 が使用されます。これによりノイズが増幅され、最終的には LAGRA = 0 に対する純粋な逆フィルターになります。</p><pre class="codeinput">reg7 = deconvreg(Edged,PSF,[],LAGRA/100);
figure;imshow(reg7);
title(<span class="string">'Restored with small LAGRA'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_10.png" alt=""> <h2>手順 6: 異なる制約の使用<a name="12"></a></h2><p>最適解のために異なる制約 (REGOP) を使用して、ブレおよびノイズを含むイメージを復元します。イメージの平滑化 (REGOP は既定でラプラシアンです) を制約する代わりに、1 次元でのみ (1-D ラプラシアン) イメージの平滑化を制約します。</p><pre class="codeinput">REGOP = [1 -2 1];
reg8 = deconvreg(BlurredNoisy,PSF,[],LAGRA,REGOP);
figure;imshow(reg8);
title(<span class="string">'Constrained by 1D Laplacian'</span>);
</pre><img vspace="5" hspace="5" src="../ipexregularized_11.png" alt=""> <p class="footer">Copyright 1993-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Deblurring Images Using a Regularized Filter  % Regularized deconvolution can be used effectively when constraints are % applied on the recovered image (e.g., smoothness) and limited information % is known about the additive noise. The blurred and noisy image is restored % by a constrained least square restoration algorithm that uses a regularized % filter.   % Copyright 1993-2005 The MathWorks, Inc. %   $Revision: 1.1.4.4.2.1 $  $Date: 2010/07/29 21:28:50 $  %% Step 1: Read Image % The example reads in an RGB image and crops it to be 256-by-256-by-3. The % deconvreg function can handle arrays of any dimension.   I = imread('tissue.png'); I = I(125+[1:256],1:256,:); figure;imshow(I);title('Original Image'); text(size(I,2),size(I,1)+15, ...     'Image courtesy of Alan Partin, Johns Hopkins University', ...     'FontSize',7,'HorizontalAlignment','right');  %% Step 2: Simulate a Blur and Noise  % Simulate a real-life image that could be blurred (e.g., due to camera motion % or lack of focus) and noisy (e.g., due to random disturbances). The example % simulates the blur by convolving a Gaussian filter with the true image (using % imfilter). The Gaussian filter represents a point-spread function, PSF.   PSF = fspecial('gaussian',11,5); Blurred = imfilter(I,PSF,'conv'); figure;imshow(Blurred); title('Blurred');  %% % We simulate the noise by adding a Gaussian noise of variance V to the blurred % image (using imnoise).   V = .02; BlurredNoisy = imnoise(Blurred,'gaussian',0,V); figure;imshow(BlurredNoisy); title('Blurred & Noisy');  %% Step 3: Restore the Blurred and Noisy Image  % Restore the blurred and noisy image supplying noise power, NP, as the third % input parameter. To illustrate how sensitive the algorithm is to the value of % noise power, NP, the example performs three restorations.  % % The first restoration, reg1, uses the true NP. Note that the example outputs % two parameters here. The first return value, reg1, is the restored image. The % second return value, LAGRA, is a scalar, Lagrange multiplier, on which the % deconvreg has converged. This value is used later in the demo.   %% NP = V*prod(size(I)); % noise power [reg1 LAGRA] = deconvreg(BlurredNoisy,PSF,NP); figure,imshow(reg1),title('Restored with NP');  %% % The second restoration, reg2, uses a slightly over-estimated noise power, % which leads to a poor resolution.   reg2 = deconvreg(BlurredNoisy,PSF,NP*1.3); figure;imshow(reg2); title('Restored with larger NP');  %% % The third restoration, reg3, is given an under-estimated NP value. This leads % to an overwhelming noise amplification and "ringing" from the image borders.   reg3 = deconvreg(BlurredNoisy,PSF,NP/1.3); figure;imshow(reg3); title('Restored with smaller NP');  %% Step 4: Reduce Noise Amplification and Ringing  % Reduce the noise amplification and "ringing" along the boundary of the image  % by calling the edgetaper function prior to deconvolution. Note how the image % restoration becomes less sensitive to the noise power parameter. Use the  % noise power value NP from the previous example.   Edged = edgetaper(BlurredNoisy,PSF); reg4 = deconvreg(Edged,PSF,NP/1.3); figure;imshow(reg4); title('Edgetaper effect');  %% Step 5: Use the Lagrange Multiplier  % Restore the blurred and noisy image, assuming that the optimal solution % is already found and the corresponding Lagrange multiplier, LAGRA, is given. % In this case, any value passed for noise power, NP, is ignored.  % % To illustrate how sensitive the algorithm is to the LAGRA value, the example % performs three restorations. The first restoration (reg5) uses the LAGRA % output from the earlier solution (LAGRA output from first solution in % Step 3).  reg5 = deconvreg(Edged,PSF,[],LAGRA); figure;imshow(reg5); title('Restored with LAGRA');  %% % The second restoration (reg6) uses 100*LAGRA which increases the significance % of the constraint. By default, this leads to over-smoothing of the image.  reg6 = deconvreg(Edged,PSF,[],LAGRA*100); figure;imshow(reg6); title('Restored with large LAGRA');  %% % The third restoration uses LAGRA/100 which weakens the constraint (the % smoothness requirement set for the image). It amplifies the noise and % eventually leads to a pure inverse filtering for LAGRA = 0.   reg7 = deconvreg(Edged,PSF,[],LAGRA/100); figure;imshow(reg7); title('Restored with small LAGRA');  %% Step 6: Use a Different Constraint  % Restore the blurred and noisy image using a different constraint (REGOP) % in the search for the optimal solution. Instead of constraining the image % smoothness (REGOP is Laplacian by default), constrain the image smoothness % only in one dimension (1-D Laplacian).   REGOP = [1 -2 1]; reg8 = deconvreg(BlurredNoisy,PSF,[],LAGRA,REGOP); figure;imshow(reg8); title('Constrained by 1D Laplacian');   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>