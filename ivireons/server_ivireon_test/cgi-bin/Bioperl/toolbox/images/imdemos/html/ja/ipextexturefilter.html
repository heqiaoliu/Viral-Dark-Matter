
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>テクスチャ フィルターを使ったテクスチャ分割</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipextexturefilter.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipextexturefilter">エディターで ipextexturefilter.m を開く</a></div><div class="right"><a href="matlab:echodemo ipextexturefilter">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>テクスチャ フィルターを使ったテクスチャ分割</h1><!--introduction--><p>テクスチャ分割は、それらのテクスチャをベースにした領域の識別です。目的は、テクスチャ フィルターを使ってイメージ内の 2 種類の繊維を区分することです。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: テクスチャ イメージの作成</a></li><li><a href="#4">手順 3: 下部テクスチャでの粗いマスクの作成</a></li><li><a href="#9">手順 4: 粗いマスクを使用した上部テクスチャの分割</a></li><li><a href="#16">手順 5: 分割結果の表示</a></li><li><a href="#19">分割での他のテクスチャ フィルターの使用</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p><tt>bag.png</tt> を読み込みます。</p><pre class="codeinput">I = imread(<span class="string">'bag.png'</span>);
figure, imshow(I);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_01.png" alt=""> <h2>手順 2: テクスチャ イメージの作成<a name="2"></a></h2><p>関数 <tt>entropyfilt</tt> を使用して、テクスチャ イメージを作成します。関数 <tt>entropyfilt</tt> は、配列を出力します。ここで、各出力ピクセルは、入力イメージ <tt>I</tt> 内の対応するピクセル周辺に 9x9 近傍のエントロピー値を含んでいます。エントロピーとは、ランダム性の統計的尺度です。</p><pre class="codeinput">E = entropyfilt(I);
</pre><p>値が double イメージの既定の範囲内にあるように、関数 <tt>mat2gray</tt> を使用して、テクスチャ イメージ <tt>E</tt> を再スケーリングします。</p><pre class="codeinput">Eim = mat2gray(E);
imshow(Eim);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_02.png" alt=""> <h2>手順 3: 下部テクスチャでの粗いマスクの作成<a name="4"></a></h2><p>再スケーリングされたイメージ <tt>Eim</tt> をしきい値処理し、テクスチャを分割します。テクスチャ間の境界線のピクセル強度値とほとんど同じであるため、しきい値 0.8 を選択します。</p><pre class="codeinput">BW1 = im2bw(Eim, .8);
</pre><pre class="codeinput">imshow(BW1);
figure, imshow(I);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_03.png" alt=""> <img vspace="5" hspace="5" src="../ipextexturefilter_04.png" alt=""> <p>バイナリ イメージ <tt>BW1</tt> の分割されたオブジェクトは白色です。<tt>BW1</tt> と <tt>I</tt> を比較した場合、上部テクスチャは過度に分割され (複数の白色オブジェクト)、下部テクスチャはほとんど全体が分割されていることに気が付きます。関数 <tt>bwareaopen</tt> を使用して下部テクスチャを抽出できます。</p><pre class="codeinput">BWao = bwareaopen(BW1,2000);
imshow(BWao);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_05.png" alt=""> <p>関数 <tt>imclose</tt> を使用して、エッジを滑らかにし、<tt>BWao</tt> のオブジェクトで開いている穴を閉じます。9x9 近傍を選択します。これは <tt>entropyfilt</tt> によっても使用されたためです。</p><pre class="codeinput">nhood = true(9);
closeBWao = imclose(BWao,nhood);
imshow(closeBWao)
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_06.png" alt=""> <p>関数 <tt>imfill</tt> を使用して、<tt>closeBWao</tt> のオブジェクトの穴を塗りつぶします。</p><pre class="codeinput">roughMask = imfill(closeBWao,<span class="string">'holes'</span>);
</pre><h2>手順 4: 粗いマスクを使用した上部テクスチャの分割<a name="9"></a></h2><p>バイナリ イメージ <tt>roughMask</tt> とオリジナル イメージ <tt>I</tt> を比較します。マスクはイメージの最下部まで拡張されていないため、下部テクスチャのマスクは完ぺきではないことに注意してください。ただし、関数 <tt>roughMask</tt> を使用して、上部テクスチャを分割できます。</p><pre class="codeinput">imshow(roughMask);
figure, imshow(I);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_07.png" alt=""> <img vspace="5" hspace="5" src="../ipextexturefilter_08.png" alt=""> <p>関数 <tt>roughMask</tt> を使用して上部テクスチャの生イメージを取得します。</p><pre class="codeinput">I2 = I;
I2(roughMask) = 0;
imshow(I2);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_09.png" alt=""> <p>関数 <tt>entropyfilt</tt> を使用して、テクスチャ イメージを計算します。</p><pre class="codeinput">E2 = entropyfilt(I2);
E2im = mat2gray(E2);
imshow(E2im);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_10.png" alt=""> <p>関数 <tt>graythresh</tt> を使用して、 <tt>E2im</tt> をしきい値処理します。</p><pre class="codeinput">BW2 = im2bw(E2im,graythresh(E2im));
</pre><pre class="codeinput">imshow(BW2)
figure, imshow(I);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_11.png" alt=""> <img vspace="5" hspace="5" src="../ipextexturefilter_12.png" alt=""> <p><tt>BW2</tt> と <tt>I</tt> を比較すると、<tt>BW2</tt> には分割されたオブジェクトが 2 つあることに気が付きます。関数 <tt>bwareaopen</tt> を使用して、上部テクスチャにマスクを取得します。</p><pre class="codeinput">mask2 = bwareaopen(BW2,1000);
imshow(mask2);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_13.png" alt=""> <h2>手順 5: 分割結果の表示<a name="16"></a></h2><p><tt>mask2</tt> を使用して、<tt>I</tt> から上部および下部テクスチャを抽出します。</p><pre class="codeinput">texture1 = I;
texture1(~mask2) = 0;
texture2 = I;
texture2(mask2) = 0;
</pre><pre class="codeinput">imshow(texture1);
figure, imshow(texture2);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_14.png" alt=""> <img vspace="5" hspace="5" src="../ipextexturefilter_15.png" alt=""> <p>2 つのテクスチャ間の境界線の輪郭を表示します。</p><pre class="codeinput">boundary = bwperim(mask2);
segmentResults = I;
segmentResults(boundary) = 255;
imshow(segmentResults);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_16.png" alt=""> <h2>分割での他のテクスチャ フィルターの使用<a name="19"></a></h2><p>関数 <tt>entropyfilt</tt> の代わりに、関数 <tt>stdfilt</tt> および <tt>rangefilt</tt> を他の形態学的関数と併用しても、同じような分割結果に達することができます。</p><pre class="codeinput">S = stdfilt(I,nhood);
imshow(mat2gray(S));
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_17.png" alt=""> <pre class="codeinput">R = rangefilt(I,ones(5));
imshow(R);
</pre><img vspace="5" hspace="5" src="../ipextexturefilter_18.png" alt=""> <p class="footer">Copyright 1993-2005 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Texture Segmentation Using Texture Filters % Texture segmentation is the identification of regions based on their % texture. Your goal is to segment two kinds of fabric in an image using % texture filters. %  % Copyright 1993-2005 The MathWorks, Inc.  %% Step 1: Read Image % Read in |bag.png|.  I = imread('bag.png'); figure, imshow(I);  %% Step 2: Create Texture Image % Use |entropyfilt| to create a texture image. The function |entropyfilt| % returns an array where each output pixel contains the entropy value of the % 9-by-9 neighborhood around the corresponding pixel in the input image |I|. % Entropy is a statistical measure of randomness.  E = entropyfilt(I);  %%  % Use |mat2gray| to rescale the texture image |E| so that its values are in % the default range for a double image.  Eim = mat2gray(E); imshow(Eim);  %% Step 3: Create Rough Mask for the Bottom Texture % Threshold the rescaled image |Eim| to segment the textures. A threshold value % of 0.8 is selected because it is roughly the intensity value of pixels along % the boundary between the textures.  BW1 = im2bw(Eim, .8); %% imshow(BW1); figure, imshow(I);  %%  % The segmented objects in the binary image |BW1| are white. If you compare % |BW1| to |I|, you notice the top texture is overly segmented (multiple % white objects) and the bottom texture is segmented almost in its % entirety.  You can extract the bottom texture using |bwareaopen|.  BWao = bwareaopen(BW1,2000); imshow(BWao);  %% % Use |imclose| to smooth the edges and to close any open holes in the % object in |BWao|. A 9-by-9 neighborhood is selected because this % neighborhood was also used by |entropyfilt|.  nhood = true(9); closeBWao = imclose(BWao,nhood); imshow(closeBWao)  %% % Use |imfill| to fill holes in the object in |closeBWao|.  roughMask = imfill(closeBWao,'holes');  %% Step 4: Use Rough Mask to Segment the Top Texture % Compare the binary image |roughMask| to the original image |I|.  Notice % the mask for the bottom texture is not perfect because the mask does not % extend to the bottom of the image.  However, you can use |roughMask| to % segment the top texture.  %% imshow(roughMask); figure, imshow(I);  %% % Get raw image of the top texture using |roughMask|.  I2 = I; I2(roughMask) = 0; imshow(I2);  %% % Use |entropyfilt| to calculate the texture image.   E2 = entropyfilt(I2); E2im = mat2gray(E2); imshow(E2im);  %% % Threshold |E2im| using |graythresh|.  BW2 = im2bw(E2im,graythresh(E2im)); %% imshow(BW2) figure, imshow(I);  %% % If you compare |BW2| to |I|, you notice there are two objects segmented % in |BW2|. Use |bwareaopen| to get a mask for the top texture.  mask2 = bwareaopen(BW2,1000); imshow(mask2);  %% Step 5: Display Segmentation Results % Use |mask2| to extract the top and bottom texture from |I|.  texture1 = I; texture1(~mask2) = 0; texture2 = I; texture2(mask2) = 0;  %% imshow(texture1); figure, imshow(texture2);  %% % Outline the boundary between the two textures.  boundary = bwperim(mask2); segmentResults = I; segmentResults(boundary) = 255; imshow(segmentResults);  %% Using Other Texture Filters in Segmentation % Instead of |entropyfilt|, you can use |stdfilt| and |rangefilt| with other % morphological functions to achieve similar segmentation results.  S = stdfilt(I,nhood); imshow(mat2gray(S));  %% R = rangefilt(I,ones(5)); imshow(R);   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>