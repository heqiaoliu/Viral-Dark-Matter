
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>累積分布関数とその逆関数のノンパラメトリック推定</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-26"><meta name="DC.source" content="nonparametricCDFdemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit nonparametricCDFdemo">エディターで nonparametricCDFdemo.m を開く</a></div><div class="right"><a href="matlab:echodemo nonparametricCDFdemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>累積分布関数とその逆関数のノンパラメトリック推定</h1><!--introduction--><p>Statistics Toolbox™ には、一変量パラメトリック確率分布用の乱数発生器関数が 20 数個用意されています。これらの関数を使用すると、さまざまなシミュレーション用の乱数入力を生成できます。ただし、簡単なパラメーター ファミリーによって記述されないデータをシミュレートするために乱数値を生成することが必要になる場合があります。</p><p>このツールボックスには、抽出元のパラメトリック分布を指定する必要なしに乱数値を生成できる、関数 <tt>pearsrnd</tt> および <tt>johnsrnd</tt> も含まれています。これらの関数を使用すると、分布のモーメントと分位数をそれぞれ指定できます。</p><p>ただし、収集したデータをさらに厳密に &quot;模倣&quot; する乱数値を生成するために、さらなる柔軟性が必要となる場合があります。この場合は、収集したデータの累積分布関数 (CDF) のノンパラメトリック推定を使用して、逆関数法を使って乱数値を生成できます。逆関数法では、一様な乱数値を単位間隔で生成し、必要な分布の逆 CDF を使用して、その分布に乱数値を変換することが必要となります。</p><p>逆の観点から見ると、CDF のノンパラメトリック推定を使用して観測データを単位間隔に変換することで、近似の一様分布を与えることが好ましい場合もあります。</p><p>関数 <tt>ecdf</tt> は、1 種類のノンパラメトリック CDF 推定、つまり階段関数である経験的 CDF を計算します。このデモでは、連続分布からのデータのシミュレートまたは変換に適している、よりスムーズな代替方法について説明します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#2">区分的線形ノンパラメトリック CDF 推定</a></li><li><a href="#7">区分的線形ノンパラメトリック逆 CDF 推定</a></li><li><a href="#10">CDF および逆 CDF 向けのカーネル推定器</a></li><li><a href="#19">セミパラメトリック CDF 推定</a></li><li><a href="#23">まとめ</a></li></ul></div><p>説明しやすくするため、ここでは簡単なシミュレーション データを使用します。また、デモ内のプロットを読みやすくするため、観測値は 25 個のみ選択してあります。プロットを簡略化するため、データの並べ替えも行われています。</p><pre class="codeinput">rand(<span class="string">'state'</span>0.2);
n = 25;
x = evrnd(3,1,n,1); x = sort(x);
hist(x,-3.75:.5:5.75);
xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'Frequency'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_01.png" alt=""> <h2>区分的線形ノンパラメトリック CDF 推定<a name="2"></a></h2><p>関数 <tt>ecdf</tt> を使用すると、経験的 &quot;階段&quot; CDF の計算とプロットを簡単に行えます。簡単なケースでは、この推定によって各データ ポイントに 1/n の離散ジャンプが作成されます。</p><pre class="codeinput">[Fi,xi] = ecdf(x);
stairs(xi,Fi,<span class="string">'r'</span>);
xlim([-4 6]); xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'F(x)'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_02.png" alt=""> <p>この推定は、パラメトリック モデルのデータに対する適合度を調査する場合など、さまざまな目的で使用できます。ただし、その離散性ゆえに、連続データと単位間隔との間の経験的変換には適していない場合があります。</p><p>この問題を解決するために経験的 CDF を変更することは簡単です。各データ ポイントで 1/n の離散ジャンプを取得する代わりに、これらのジャンプの中点にブレークポイントを置き、区分的に線形の関数を定義します。これにより、各データ ポイントにおける高さは、[(1/n), (2/n), ..., 1] ではなく [1/2n, 3/2n, ..., (n-1/2)/n] になります。<tt>ecdf</tt> の出力を使用して上記のブレークポイントを計算し、&quot;ドットを連結&quot; して区分的線形関数を定義します。</p><pre class="codeinput">xj = xi(2:end);
Fj = (Fi(1:end-1)+Fi(2:end))/2;
hold <span class="string">on</span>
plot(xj,Fj,<span class="string">'b.'</span>, xj,Fj,<span class="string">'b-'</span>);
hold <span class="string">off</span>
legend({<span class="string">'ECDF'</span> <span class="string">'Breakpoints'</span> <span class="string">'Piecewise Linear Estimate'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_03.png" alt=""> <p><tt>ecdf</tt> は反復値と打ち切りを近似的に処理するため、この例より複雑なデータを使用する場合でも、この計算は正しく行われます。</p><p>最小のデータ ポイントは高さ 1/2n に対応し、最大のデータ ポイントは高さ 1-1/2n に対応するため、関数が 0 および 1 に達するようにするには、最初と最後の線形セグメントをこれらのデータ以上に拡張させなければなりません。</p><pre class="codeinput">xj = [xj(1)-Fj(1)*(xj(2)-xj(1))/((Fj(2)-Fj(1)));
      xj;
      xj(n)+(1-Fj(n))*((xj(n)-xj(n-1))/(Fj(n)-Fj(n-1)))];
Fj = [0; Fj; 1];
hold <span class="string">on</span>
plot(xj,Fj,<span class="string">'b-'</span>);
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_04.png" alt=""> <p>この区分的線形関数からは、連続かつ対称である CDF のノンパラメトリック推定が得られます。オリジナル データ以外のポイントで評価するには、線形補間を行うだけでよく、無名関数を定義しておくと評価を簡単に行えるようになります。</p><pre class="codeinput">F = @(y) interp1(xj,Fj,y,<span class="string">'linear'</span>,<span class="string">'extrap'</span>);
y = linspace(-2,4,10);
plot(xj,Fj,<span class="string">'b-'</span>,y,F(y),<span class="string">'ko'</span>);
xlim([-4 6]); xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'F(x)'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_05.png" alt=""> <h2>区分的線形ノンパラメトリック逆 CDF 推定<a name="7"></a></h2><p>これと同じ計算を使用して、逆 CDF のノンパラメトリック推定を計算できます。実際、逆 CDF 推定は、軸を交換しただけの CDF 推定にすぎません。</p><pre class="codeinput">stairs(Fi,[xi(2:end); xi(end)],<span class="string">'r'</span>);
hold <span class="string">on</span>
plot(Fj,xj,<span class="string">'b-'</span>);
hold <span class="string">off</span>
ylim([-4 6]); ylabel(<span class="string">'x'</span>); xlabel(<span class="string">'F(x)'</span>);
legend({<span class="string">'ECDF'</span> <span class="string">'Piecewise Linear Estimate'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_06.png" alt=""> <p>このノンパラメトリック逆 CDF をオリジナル ブレークポイント以外のポイントで評価する場合も、先ほどと同様に線形補間を行うだけですみます。たとえば、一様乱数値を生成し、CDF 推定を使用して、これらの乱数値をオリジナルの観測データの尺度に変換し直します。これを逆関数法と呼びます。</p><pre class="codeinput">Finv = @(u) interp1(Fj,xj,u,<span class="string">'linear'</span>,<span class="string">'extrap'</span>);
u = rand(10000.1);
hist(Finv(u),-3.875:.25:5.875);
xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'Frequency'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_07.png" alt=""> <p>シミュレートされたデータのヒストグラムが、オリジナル データのヒストグラムより分散していることに注目してください。この原因の 1 つとして、オリジナル データがわずか 25 個の値から成るのに対し、シミュレートされたデータのサンプル サイズが格段に大きいことが挙げられます。また、区分的線形 CDF 推定によって、オリジナルの各観測値が一定の間隔にわたって実質的に &quot;分散&quot; されることも、もう 1 つの原因です。このことは、個々の観測値が厳密に分離されている領域に特に当てはまります。</p><p>たとえば、零点の左にある 2 つの個々の観測値は、シミュレートされたデータ内の広く平坦な低密度領域に対応します。その逆に、右裾に向かった領域など、データ間隔が狭い領域では、区分的線形 CDF 推定による観測値の &quot;分散&quot; の度合いが低くなります。その意味で、この推定法では、簡単な形式の可変帯域幅平滑化が実行されます。ただし、平滑化されても、シミュレートされたデータはオリジナル データの特性 (つまり、高密度領域と低密度領域) をほとんど維持します。</p><h2>CDF および逆 CDF 向けのカーネル推定器<a name="10"></a></h2><p>区分的線形関数を使用して CDF を推定する代わりに、関数 <tt>ksdensity</tt> を使用してカーネル推定を実行することで、滑らかなノンパラメトリック推定を行うことができます。<tt>ksdensity</tt> は、ノンパラメトリックな密度<i></i>推定を行うために使用されるのが一般的ですが、他の関数を推定することもできます。たとえば、オリジナル データを単位間隔に変換するには、この関数を使用して CDF を推定します。</p><pre class="codeinput">F = ksdensity(x, x, <span class="string">'function'</span>,<span class="string">'cdf'</span>, <span class="string">'width'</span>,.35);
stairs(xi,Fi,<span class="string">'r'</span>);
hold <span class="string">on</span>
plot(x,F,<span class="string">'b.'</span>);
hold <span class="string">off</span>
xlim([-4 6]); xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'F(x)'</span>);
legend({<span class="string">'ECDF'</span> <span class="string">'Kernel Estimates'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_08.png" alt=""> <p><tt>ksdensity</tt> を使用すると、オリジナル データ以外のポイントでカーネル CDF 推定を簡単に評価することもできます。たとえば、滑らかな曲線として推定をプロットします。</p><pre class="codeinput">y = linspace(-4.60.1000);
Fy = ksdensity(x, y, <span class="string">'function'</span>,<span class="string">'cdf'</span>, <span class="string">'width'</span>,.35);
stairs(xi,Fi,<span class="string">'r'</span>);
hold <span class="string">on</span>
plot(y,Fy,<span class="string">'b-'</span>);
hold <span class="string">off</span>
legend({<span class="string">'ECDF'</span> <span class="string">'Kernel Estimate'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_09.png" alt=""> <p><tt>ksdensity</tt> は、帯域幅パラメーターを使用して、計算対象の推定における平滑化の量を制御します。<tt>ksdensity</tt> によって既定値が自動的に選択されるようにすることもできます。ここに示す例では、非常に小さな帯域幅を使用して、平滑化の量を制限しています。それにもかかわらず、カーネル推定は、区分的線形推定ほど厳密には ECDF に従いません。</p><p>カーネル推定を使用して逆 CDF を推定する方法の 1 つは、オリジナル データの範囲にあるグリッド ポイントに対するカーネル CDF 推定を計算してから、区分的線形推定の場合と同じ手順に従うことです。たとえば、逆 CDF カーネル推定を滑らかな曲線としてプロットするには、単に軸を交換します。</p><pre class="codeinput">stairs(Fi,[xi(2:end); xi(end)],<span class="string">'r'</span>);
hold <span class="string">on</span>
plot(Fy,y,<span class="string">'b-'</span>);
hold <span class="string">off</span>
ylim([-4 6]); ylabel(<span class="string">'x'</span>); xlabel(<span class="string">'F(x)'</span>);
legend({<span class="string">'ECDF'</span> <span class="string">'Kernel Estimate'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_10.png" alt=""> <p>一様な乱数値をオリジナル データの尺度に変換し直すには、CDF 推定のグリッドを使用して補間します。</p><pre class="codeinput">Finv = @(u) interp1(Fy,y,u,<span class="string">'linear'</span>,<span class="string">'extrap'</span>);
hist(Finv(u),-3.875:.25:5.875);
xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'Frequency'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_11.png" alt=""> <p>カーネル CDF 推定を使用してシミュレートされたデータは、オリジナル データに含まれている零点の左側にある 2 つの個々の観測値では完全には &quot;平滑化&quot; されていません。カーネル推定では固定帯域幅が使用されます。上記の 2 つの観測値は、区分的線形推定の場合は広く平坦な領域に寄与しましたが、この例の帯域幅値を使用すると、局所化された 2 つの高密度領域に寄与します。それとは対照的に、カーネル推定では、右裾部分のデータが区分的線形推定の場合より平準化されます。<i></i></p><p>カーネル推定を使用してシミュレートされたデータを生成するもう 1 つの方法は、<tt>ksdensity</tt> を使用して逆 CDF の推定を直接計算することです。ここでもまた、<tt>'function'</tt> パラメーターを使用します。たとえば、上記と同じ一様な値を変換します。</p><pre class="codeinput">r = ksdensity(x, u, <span class="string">'function'</span>,<span class="string">'icdf'</span>, <span class="string">'width'</span>,.35);
</pre><p>ただし、後者の方法は、データが大量にある場合に時間がかかります。これより簡単でありながら同等の方法は、オリジナル データからの置き換えを使ってリサンプリングして、乱数による適切な誤差を追加する方法です。</p><pre class="codeinput">r = randsample(x,100000,true) + normrnd(0,.3,100000,1);
</pre><p>十分な乱数値を生成すると、結果のヒストグラムは、オリジナル データのカーネル密度推定に厳密に従うようになります。</p><pre class="codeinput">binwidth = .25;
edges = -4:binwidth:6;
ctrs = edges(1:end-1) + binwidth./2;
counts = histc(r,edges); counts = counts(1:end-1);
bar(ctrs,counts./(sum(counts).*binwidth),1,<span class="string">'FaceColor'</span>,[.9 .9 .9]);
hold <span class="string">on</span>
xgrid = edges(1):.1:edges(end);
fgrid = ksdensity(x, xgrid, <span class="string">'function'</span>,<span class="string">'pdf'</span>, <span class="string">'width'</span>,.35);
plot(xgrid,fgrid,<span class="string">'k-'</span>);
hold <span class="string">off</span>
xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'f(x)'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_12.png" alt=""> <h2>セミパラメトリック CDF 推定<a name="19"></a></h2><p>ノンパラメトリック CDF 推定では、妥当な精度を実現するために相当な量のデータが必要となります。また、データは &quot;局所的&quot; にしか推定に影響を与えません。つまり、データ密度の高い領域では、データ密度の低い領域より多くの観測値に基づいて推定が行われます。そのため、ノンパラメトリック推定は、データが希薄となる、分布の裾部分では正しく実行されません。</p><p>関数 <tt>paretotails</tt> を使用してセミパラメトリック モデルをデータに近似させると、ノンパラメトリックとパラメトリックの両方のメリットを得ることができます。セミパラメトリック モデルは、分布の &quot;中心&quot; では、CDF に対して区分的線形ノンパラメトリック推定を使用し、各裾部分では、一般化パレート分布を使用します。一般化パレート分布は、多くの場合、データセットの裾に対するモデルとして使用されます。この分布は、さまざまな分布の裾に近似するのに十分な柔軟性を備えていると同時に、データをほとんど必要とせずに裾データに滑らかに近似するのに十分な制約も受けています。</p><p>たとえば、データの &quot;中心&quot; を中央の 60% として定義して、ノンパラメトリック推定とパレート近似との間の遷移がデータの分位数 0.20 と 0.80 で起こるものと指定します。セミパラメトリック モデル近似の CDF を評価するには、近似の <tt>cdf</tt> メソッドを使用します。</p><pre class="codeinput">semipFit = paretotails(x,.20,.80);
</pre><pre class="codeoutput">警告:Problem fitting generalized Pareto distribution to lower tail.
Maximum likelihood has converged to a boundary point of the parameter space. 
</pre><p>この警告は、使用するデータが少なすぎる (この場合は裾ごとに 5 ポイント) ために表示されるもので、低い方の裾部分にある近似一般化パレート分布が最小の観測値までしか拡張されないことを示しています。実際の状況では、データ量がこれより多い場合が大半であるため、通常この警告は発生しません。</p><pre class="codeinput">[p,q] = boundary(semipFit);
y = linspace(-4.60.1000);
Fy = cdf(semipFit,y);
plot(y,Fy,<span class="string">'b-'</span>, q,p,<span class="string">'k+'</span>);
xlim([-4 6]); xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'F(x)'</span>);
legend({<span class="string">'Semi-parametric Estimate'</span> <span class="string">'Segment Boundaries'</span>},<span class="string">'location'</span>,<span class="string">'NW'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_13.png" alt=""> <p>一様乱数値をオリジナル データの尺度に変換し直すには、近似の <tt>icdf</tt> メソッドを使用します。</p><pre class="codeinput">r = icdf(semipFit,u);
hist(r,-3.875:.25:5.875);
xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'Frequency'</span>);
</pre><img vspace="5" hspace="5" src="../nonparametricCDFdemo_14.png" alt=""> <p>このセミパラメトリック推定は、データの裾部分で使用されるパラメトリック モデルが原因で、中心部より裾部分で平滑化されています。その意味で、この場合の推定は、カーネル推定より区分的線形推定に対する類似性が高くなります。ただし、<tt>paretotails</tt> を使用することによって、データの中心部でカーネル推定を使用するセミパラメトリック近似を作成することも可能です。</p><h2>まとめ<a name="23"></a></h2><p>このデモでは、ノンパラメトリック CDF、セミパラメトリック CDF、または逆 CDF の各推定をデータから計算するための 3 通りの方法について説明しました。これらの 3 つの方法では、データに対する平滑化の量と種類がそれぞれ異なります。どの方法を選択すべきかは、データの重要な特長と考えられるものをどの方法で取り込むことができるかどうかによって決まります。</p><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Nonparametric Estimates of Cumulative Distribution Functions and Their Inverses % The Statistics Toolbox(TM) includes more than two dozen random number generator % functions for parametric univariate probability distributions. These functions % allow you to generate random inputs for a wide variety of simulations, % however, there are situations where it is necessary to generate random values % to simulate data that are not described by a simple parametric family. % % The toolbox also includes the functions |pearsrnd| and |johnsrnd|, for % generating random values without having to specify a parametric distribution % from which to drawREPLACE_WITH_DASH_DASHthose functions allow you to specify a distribution in % terms of its moments or quantiles, respectively. % % However, there are still situations where even more flexibility is needed, % to generate random values that "imitate" data that you have collected even % more closely. In this case, you might use a nonparametric estimate of the % cumulative distribution function (CDF) of those data, and use the inversion % method to generate random values.  The inversion method involves generating % uniform random values on the unit interval, and transforming them to a % desired distribution using the inverse CDF for that distribution. % % From the opposite perspective, it is sometimes desirable to use a % nonparametric estimate of the CDF to transform observed data onto the unit % interval, giving them an approximate uniform distribution. % % The |ecdf| function computes one type of nonparametric CDF estimate, the % empirical CDF, which is a stairstep function.  This demo illustrates some % smoother alternatives, which may be more suitable for simulating or % transforming data from a continuous distribution.  %   Copyright 2007-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:29:29 $  %% % For the purpose of illustration, here are some simple simulated data. There % are only 25 observations, a small number chosen to make the plots in the demo % easier to read.  The data are also sorted to simplify plotting.  rand('state',2); n = 25; x = evrnd(3,1,n,1); x = sort(x); hist(x,-3.75:.5:5.75); xlabel('x'); ylabel('Frequency');   %% A Piecewise Linear Nonparametric CDF Estimate % The |ecdf| function provides a simple way to compute and plot a "stairstep" % empirical CDF for data.  In the simplest cases, this estimate makes discrete % jumps of 1/n at each data point. [Fi,xi] = ecdf(x); stairs(xi,Fi,'r'); xlim([-4 6]); xlabel('x'); ylabel('F(x)');  %% % This estimate is useful for many purposes, including investigating the % goodness of fit of a parametric model to data.  Its discreteness, however, may % make it unsuitable for use in empirically transforming continuous data to or % from the unit interval. % % It is simple to modify the empirical CDF to address that problems. Instead % of taking discrete jumps of 1/n at each data point, define a function that % is piecewise linear, with breakpoints at the midpoints of those jumps. The % height at each of the data points is then [1/2n, 3/2n, ..., (n-1/2)/n], % instead of [(1/n), (2/n), ..., 1].  Use the output of |ecdf| to % compute those breakpoints, and then "connect the dots" to define the % piecewise linear function. xj = xi(2:end); Fj = (Fi(1:end-1)+Fi(2:end))/2; hold on plot(xj,Fj,'b.', xj,Fj,'b-'); hold off legend({'ECDF' 'Breakpoints' 'Piecewise Linear Estimate'},'location','NW');  %% % Because |ecdf| deals appropriately with repeated values and censoring, this % calculation works even in cases with more complicated data than in this % example.  %% % Since the smallest data point corresponds to a height of 1/2n, and the % largest to 1-1/2n, the first and last linear segments must be extended beyond % the data, to make the function reach 0 and 1. xj = [xj(1)-Fj(1)*(xj(2)-xj(1))/((Fj(2)-Fj(1)));       xj;       xj(n)+(1-Fj(n))*((xj(n)-xj(n-1))/(Fj(n)-Fj(n-1)))]; Fj = [0; Fj; 1]; hold on plot(xj,Fj,'b-'); hold off %% % This piecewise linear function provides a nonparametric estimate of the CDF % that is continuous and symmetric.  Evaluating it at points other than the % original data is just a matter of linear interpolation, and it can be % convenient to define an anonymous function to do that. F = @(y) interp1(xj,Fj,y,'linear','extrap'); y = linspace(-2,4,10); plot(xj,Fj,'b-',y,F(y),'ko'); xlim([-4 6]); xlabel('x'); ylabel('F(x)');   %% A Piecewise Linear Nonparametric Inverse CDF Estimate % You can use the same calculations to compute a nonparametric estimate of the % inverse CDF. In fact, the inverse CDF estimate is just the CDF estimate with % the axes swapped. stairs(Fi,[xi(2:end); xi(end)],'r'); hold on plot(Fj,xj,'b-'); hold off ylim([-4 6]); ylabel('x'); xlabel('F(x)'); legend({'ECDF' 'Piecewise Linear Estimate'},'location','NW');  %% % Evaluating this nonparametric inverse CDF at points other than the original % breakpoints is again just a matter of linear interpolation.  For example, % generate uniform random values and use the CDF estimate to transform them % back to the scale of your original observed data.  This is the inversion % method. Finv = @(u) interp1(Fj,xj,u,'linear','extrap'); u = rand(10000,1); hist(Finv(u),-3.875:.25:5.875); xlabel('x'); ylabel('Frequency');  %% % Notice that this histogram of simulated data is more spread out than the % histogram of the original data.  This is due, in part, to the much larger % sample sizeREPLACE_WITH_DASH_DASHthe original data consist of only 25 values.   But it is also % because the piecewise linear CDF estimate, in effect, "spreads out" each of % the original observations over an interval, and more so in regions where the % individual observations are well-separated. % % For example, the two individual observations to the left of zero correspond % to a wide, flat region of low density in the simulated data.  In contrast, % in regions where the data are closely spaced, towards the right tail, for % example, the piecewise linear CDF estimate "spreads out" the observations to % a lesser extent.  In that sense, the method performs a simple version of % what is known as variable bandwidth smoothing.  However, despite the % smoothing, the simulated data retain most of the idiosyncrasies of the % original data, i.e., the regions of high and low density.   %% Kernel Estimators for the CDF and Inverse CDF % Instead of estimating the CDF using a piecewise linear function, you can % perform kernel estimation using the |ksdensity| function to make a smooth % nonparametric estimate. Though it is often used to make a nonparametric % _density_ estimate, |ksdensity| can also estimate other functions.  For % example, to transform your original data to the unit interval, use it to % estimate the CDF. F = ksdensity(x, x, 'function','cdf', 'width',.35); stairs(xi,Fi,'r'); hold on plot(x,F,'b.'); hold off xlim([-4 6]); xlabel('x'); ylabel('F(x)'); legend({'ECDF' 'Kernel Estimates'},'location','NW');  %% % |ksdensity| also provides a convenient way to evaluate the kernel CDF % estimate at points other than the original data.  For example, plot the % estimate as a smooth curve. y = linspace(-4,6,1000); Fy = ksdensity(x, y, 'function','cdf', 'width',.35); stairs(xi,Fi,'r'); hold on plot(y,Fy,'b-'); hold off legend({'ECDF' 'Kernel Estimate'},'location','NW');  %% % |ksdensity| uses a bandwidth parameter to control the amount of smoothing in % the estimates it computes, and it is possible to let |ksdensity| choose a % default value.  The examples here use a fairly small bandwidth to limit the % amount of smoothing.  Even so, the kernel estimate does not follow the ECDF % as closely as the piecewise linear estimate does.   %% % One way to estimate the inverse CDF using kernel estimation is to compute the % kernel CDF estimate on a grid of points spanning the range of the original % data, and then use the same procedure as for the piecewise linear estimate.  For % example, to plot the inverse CDF kernel estimate as a smooth curve, simply % swap the axes. stairs(Fi,[xi(2:end); xi(end)],'r'); hold on plot(Fy,y,'b-'); hold off ylim([-4 6]); ylabel('x'); xlabel('F(x)'); legend({'ECDF' 'Kernel Estimate'},'location','NW');  %%  % To transform uniform random values back to the scale of the original data,  % interpolate using the grid of CDF estimates. Finv = @(u) interp1(Fy,y,u,'linear','extrap'); hist(Finv(u),-3.875:.25:5.875); xlabel('x'); ylabel('Frequency');  %% % Notice that the simulated data using the kernel CDF estimate has not % completely "smoothed over" the two individual observations to the left of % zero present in the original data.  The kernel estimate uses a fixed % bandwidth.  With the particular bandwidth value used in this example, those % two observations contribute to two localized areas of density, rather than a % wide flat region as was the case with the piecewise linear estimate. In % contrast, the kernel estimate has smoothed the data _more_ in the right tail % than the piecewise linear estimate.  %% % Another way to generate simulated data using kernel estimation is to use % |ksdensity| to compute an estimate of the inverse CDF directly, again using % the |'function'| parameter.  For example, transform those same uniform values. r = ksdensity(x, u, 'function','icdf', 'width',.35);  %% % However, using the latter method can be time-consuming for large amounts of % data. A simpler, but equivalent, method is to resample with replacement from % the original data and add some appropriate random noise. r = randsample(x,100000,true) + normrnd(0,.3,100000,1);  %% % If you generate enough random values, a histogram of the result follows the % kernel density estimate of the original data very closely. binwidth = .25; edges = -4:binwidth:6; ctrs = edges(1:end-1) + binwidth./2; counts = histc(r,edges); counts = counts(1:end-1); bar(ctrs,counts./(sum(counts).*binwidth),1,'FaceColor',[.9 .9 .9]); hold on xgrid = edges(1):.1:edges(end); fgrid = ksdensity(x, xgrid, 'function','pdf', 'width',.35); plot(xgrid,fgrid,'k-'); hold off xlabel('x'); ylabel('f(x)');   %% A Semiparametric CDF Estimate % A nonparametric CDF estimate requires a good deal of data to achieve % reasonable precision.  In addition, data only affect the estimate "locally." % That is, in regions where there is a high density of data, the estimate is % based on more observations than in regions where there is a low density of % data.  In particular, nonparametric estimates do not perform well in the % tails of a distribution, where data are sparse by definition. % % Fitting a semiparametric model to your data using the |paretotails| function % allows the best of both the nonparametric and parametric worlds.  In the % "center" of the distribution, the model uses the piecewise linear % nonparametric estimate for the CDF.  In each tail, it uses a generalized % Pareto distribution.  The generalized Pareto is often used as a model for % the tail(s) of a dataset, and while it is flexible enough to fit a wide % variety of distribution tails, it is sufficiently constrained so that it % requires few data to provide a plausible and smooth fit to tail data. % % For example, you might define the "center" of the data as the middle 60%, and % specify that the transitions between the nonparametric estimate and the Pareto % fits take place at the .20 and .80 quantiles of your data.  To evaluate the % CDF of the semiparametric model fit, use the fit's |cdf| method. semipFit = paretotails(x,.20,.80); %% % The warning is due to using so few dataREPLACE_WITH_DASH_DASH5 points in each tail in this % caseREPLACE_WITH_DASH_DASHand indicates that the fitted generalized Pareto distribution in the lower % tail extends exactly to the smallest observation, and no further.  In a real % application, you would usually have more data, and the warning would typically % not occur. [p,q] = boundary(semipFit); y = linspace(-4,6,1000); Fy = cdf(semipFit,y); plot(y,Fy,'b-', q,p,'k+'); xlim([-4 6]); xlabel('x'); ylabel('F(x)'); legend({'Semi-parametric Estimate' 'Segment Boundaries'},'location','NW');  %% % To transform uniform random values back to the scale of your original data, % use the fit's |icdf| method. r = icdf(semipFit,u); hist(r,-3.875:.25:5.875); xlabel('x'); ylabel('Frequency');  %% % This semiparametric estimate has smoothed the tails of the data more than % the center, because of the parametric model used in the tails.  In that % sense, the estimate is more similar to the piecewise linear estimate than to % the kernel estimate. However, it is also possible to use |paretotails| to % create a semiparametric fit that uses kernel estimation in the center of the % data.   %% Conclusions % This demo illustrates three methods for computing a non- or semi-parametric % CDF or inverse CDF estimate from data.  The three methods impose different % amounts and types of smoothing on the data.  Which method you choose depends % on how each method captures or fails to capture what you consider the % important features of your data.   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>